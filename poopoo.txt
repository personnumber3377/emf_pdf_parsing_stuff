Line: The EMR_ALPHABLEND record specifies a block transfer of pixels from a source bitmap to a wasn't a variable thing
Line: destination rectangle, including alpha transparency data, according to a specified blending wasn't a variable thing
Line: operation.<56> wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: 78 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: xDest wasn't a variable thing
Line: yDest wasn't a variable thing
Line: cxDest wasn't a variable thing
Line: cyDest wasn't a variable thing
Line: BLENDFUNCTION wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: XformSrc (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: BkColorSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: cxSrc wasn't a variable thing
Line: cySrc wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: 79 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 3623
Line: value is 0x00000072. wasn't a variable thing
Here is a field: Bounds
Line index: 3625
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: xDest
Line index: 3629
Line: the destination rectangle. wasn't a variable thing
Here is a field: yDest
Line index: 3631
Line: the destination rectangle. wasn't a variable thing
Here is a field: cxDest
Line index: 3633
Line: value MUST be greater than zero. wasn't a variable thing
Here is a field: cyDest
Line index: 3635
Line: value MUST be greater than zero. wasn't a variable thing
Here is a field: BLENDFUNCTION
Line index: 3637
Line: destination bitmaps. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: BlendOperation BlendFlags SrcConstantAlpha AlphaFormat wasn't a variable thing
Line: BlendOperation (1 byte): The blend operation code. The only source and destination blend wasn't a variable thing
Line: operation that has been defined is 0x00, which specifies that the source bitmap MUST be wasn't a variable thing
Line: combined with the destination bitmap based on the alpha transparency values of the source wasn't a variable thing
Line: pixels. See the following equations for details. wasn't a variable thing
Line: BlendFlags (1 byte): This value is 0x00 and MUST be ignored. wasn't a variable thing
Line: SrcConstantAlpha (1 byte): An unsigned integer that specifies alpha transparency, which wasn't a variable thing
Line: determines the blend of the source and destination bitmaps. This value MUST be used on the wasn't a variable thing
Line: entire source bitmap. The minimum alpha transparency value, zero, corresponds to completely wasn't a variable thing
Line: transparent; the maximum value, 0xFF, corresponds to completely opaque. In effect, a value wasn't a variable thing
Line: of 0xFF specifies that the per-pixel alpha values determine the blend of the source and wasn't a variable thing
Line: destination bitmaps. See the equations later in this section for details. wasn't a variable thing
Line: AlphaFormat (1 byte): A structure that specifies how source and destination pixels are wasn't a variable thing
Line: interpreted with respect to alpha transparency. wasn't a variable thing
Line: Value Meaning wasn't a variable thing
Line: 0x00 The pixels in the source bitmap do not specify alpha transparency. In this case, the wasn't a variable thing
Line: SrcConstantAlpha value determines the blend of the source and destination bitmaps. wasn't a variable thing
Line: Note that in the following equations SrcConstantAlpha is divided by 255, which wasn't a variable thing
Line: produces a value in the range 0 to 1. wasn't a variable thing
Line: AC_SRC_ALPHA wasn't a variable thing
Line: 0x01 wasn't a variable thing
Line: Indicates that the source bitmap is 32 bits-per-pixel and specifies an alpha transparency wasn't a variable thing
Line: value for each pixel. wasn't a variable thing
Line: 80 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: xSrc
Line index: 3674
Line: source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 3676
Line: source rectangle. wasn't a variable thing
Here is a field: XformSrc
Line index: 3678
Here is a field: BkColorSrc
Line index: 3679
Line: color of the source bitmap. wasn't a variable thing
Here is a field: UsageSrc
Line index: 3681
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: offBmiSrc
Line index: 3683
Line: record to the source bitmap header in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 3685
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 3687
Line: record to the source bitmap bits in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 3689
Here is a field: cxSrc
Line index: 3690
Line: MUST be greater than zero. wasn't a variable thing
Here is a field: cySrc
Line index: 3692
Line: MUST be greater than zero. wasn't a variable thing
Line: BitmapBuffer (variable): A buffer containing the source bitmap, which is not required to be WAS a variable thing
Line: contiguous with the fixed portion of the EMR_ALPHABLEND record. Thus, fields in this buffer wasn't a variable thing
Line: that are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: 81 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: The following equations show how destination pixels are computed from source pixels using wasn't a variable thing
Line: BLENDFUNCTION. In the equations, "dst" refers to the destination bitmap, and "src" refers to the wasn't a variable thing
Line: source bitmap. The color and transparency values of the source and destination pixels are denoted by wasn't a variable thing
Line: "Red", "Green", "Blue", and "Alpha". wasn't a variable thing
Line: Case I: The AlphaFormat value is 0, which means the SrcConstantAlpha value MUST be used to wasn't a variable thing
Line: blend the source and destination bitmaps, as follows. wasn't a variable thing
Line: dst.Red = src.Red * (SrcConstantAlpha/255.0) + wasn't a variable thing
Line:  dst.Red * (1.0 - (SrcConstantAlpha/255.0)) wasn't a variable thing
Line:  wasn't a variable thing
Line: dst.Green = src.Green * (SrcConstantAlpha/255.0) + wasn't a variable thing
Line:  dst.Green * (1.0 - (SrcConstantAlpha/255.0)) wasn't a variable thing
Line:  wasn't a variable thing
Line: dst.Blue = src.Blue * (SrcConstantAlpha/255.0) + wasn't a variable thing
Line:  dst.Blue * (1.0 - (SrcConstantAlpha/255.0)) wasn't a variable thing
Line:  wasn't a variable thing
Line: If the destination bitmap has an alpha channel, then it is blended as follows. wasn't a variable thing
Line: dst.Alpha = src.Alpha * (SrcConstantAlpha/255.0) + wasn't a variable thing
Line:  dst.Alpha * (1.0 - (SrcConstantAlpha/255.0)) wasn't a variable thing
Line:  wasn't a variable thing
Line: Note that if SrcConstantAlpha is 0xFF, these equations reduce to a simple source copy to the wasn't a variable thing
Line: destination. wasn't a variable thing
Line: Case II: The AlphaFormat value is AC_SRC_ALPHA, which means the source pixels MUST be wasn't a variable thing
Line: premultiplied by SrcConstantAlpha, and then the blend MUST be based on the per-pixel source alpha wasn't a variable thing
Line: channel, as follows. wasn't a variable thing
Line: src.Red = src.Red * (SrcConstantAlpha/255.0) wasn't a variable thing
Line:  wasn't a variable thing
Line: src.Green = src.Green * (SrcConstantAlpha/255.0) wasn't a variable thing
Line:  wasn't a variable thing
Line: src.Blue = src.Blue * (SrcConstantAlpha/255.0) wasn't a variable thing
Line:  wasn't a variable thing
Line: dst.Red = src.Red + (1.0 - (src.Alpha/255.0)) * dst.Red wasn't a variable thing
Line:  wasn't a variable thing
Line: dst.Green = src.Green + (1.0 - (src.Alpha/255.0)) * dst.Green wasn't a variable thing
Line:  wasn't a variable thing
Line: dst.Blue = src.Blue + (1.0 - (src.Alpha/255.0)) * dst.Blue wasn't a variable thing
Line:  wasn't a variable thing
Line:  wasn't a variable thing
Line: If the destination bitmap has an alpha channel, it is blended as follows. wasn't a variable thing
Line: src.Alpha = src.Alpha * (SrcConstantAlpha)/255.0) wasn't a variable thing
Line:  wasn't a variable thing
Line: dst.Alpha = src.Alpha + (1.0 - (src.Alpha/255.0)) * dst.Alpha wasn't a variable thing
Line:  wasn't a variable thing
Line: If SrcConstantAlpha is 0xFF, there is in effect no premultiplication of the source values. wasn't a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Line: 82 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_ALPHABLEND
has_variable: True
fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_ALPHABLEND
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Bullshit after...
Name: EMR_ALPHABLEND
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Line: The EMR_BITBLT record specifies a block transfer of pixels from a source bitmap to a destination wasn't a variable thing
Line: rectangle, optionally in combination with a brush pattern, according to a specified raster operation. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: xDest wasn't a variable thing
Line: yDest wasn't a variable thing
Line: cxDest wasn't a variable thing
Line: cyDest wasn't a variable thing
Line: BitBltRasterOperation wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: XformSrc (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: BkColorSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: 83 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 3809
Line: 0x0000004C. wasn't a variable thing
Here is a field: Bounds
Line index: 3811
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: xDest
Line index: 3815
Line: the destination rectangle. wasn't a variable thing
Here is a field: yDest
Line index: 3817
Line: the destination rectangle. wasn't a variable thing
Here is a field: cxDest
Line index: 3819
Line: rectangles. wasn't a variable thing
Here is a field: cyDest
Line index: 3821
Line: rectangles. wasn't a variable thing
Here is a field: BitBltRasterOperation
Line index: 3823
Line: code defines how the color data of the source rectangle is to be combined with the color data of wasn't a variable thing
Line: the destination rectangle and optionally a brush pattern, to achieve the final color. wasn't a variable thing
Line: This value is in the Ternary Raster Operation enumeration ([MS-WMF] section 2.1.1.31). wasn't a variable thing
Here is a field: xSrc
Line index: 3827
Line: source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 3829
Line: source rectangle. wasn't a variable thing
Here is a field: XformSrc
Line index: 3831
Here is a field: BkColorSrc
Line index: 3832
Line: color of the source bitmap. wasn't a variable thing
Here is a field: UsageSrc
Line index: 3834
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: offBmiSrc
Line index: 3836
Line: record to the source bitmap header in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 3838
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 3840
Line: record to the source bitmap bits in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 3842
Line: 84 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: BitmapBuffer (variable): A buffer containing the source bitmap, which is not required to be WAS a variable thing
Line: contiguous with the fixed portion of the EMR_BITBLT record. Thus, fields in this buffer that are wasn't a variable thing
Line: labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: If the raster operation specified by BitBltRasterOperation does not require a source bitmap, the wasn't a variable thing
Line: source bitmap can be omitted. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Name: EMR_BITBLT
has_variable: True
fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_BITBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Bullshit after...
Name: EMR_BITBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Line: The EMR_MASKBLT record specifies a block transfer of pixels from a source bitmap to a destination wasn't a variable thing
Line: rectangle, optionally in combination with a brush pattern and with the application of a color mask wasn't a variable thing
Line: bitmap, according to specified foreground and background raster operations. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: 85 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: xDest wasn't a variable thing
Line: yDest wasn't a variable thing
Line: cxDest wasn't a variable thing
Line: cyDest wasn't a variable thing
Line: ROP4 wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: XformSrc (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: BkColorSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: xMask wasn't a variable thing
Line: yMask wasn't a variable thing
Line: UsageMask wasn't a variable thing
Line: offBmiMask wasn't a variable thing
Line: cbBmiMask wasn't a variable thing
Line: offBitsMask wasn't a variable thing
Line: cbBitsMask wasn't a variable thing
Line: 86 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 3925
Line: 0x0000004E. wasn't a variable thing
Here is a field: Bounds
Line index: 3927
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: xDest
Line index: 3931
Line: the destination rectangle. wasn't a variable thing
Here is a field: yDest
Line index: 3933
Line: the destination rectangle. wasn't a variable thing
Here is a field: cxDest
Line index: 3935
Here is a field: cyDest
Line index: 3936
Here is a field: ROP4
Line index: 3937
Line: foreground and background colors of a bitmap. These values define how the color data of the wasn't a variable thing
Line: source rectangle is to be combined with the color data of the destination rectangle. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Reserved BackgroundROP3 ForegroundROP3 wasn't a variable thing
Here is a field: Reserved
Line index: 3948
Line: BackgroundROP3 (1 byte): The unsigned, most-significant 8 bits of a 24-bit ternary raster wasn't a variable thing
Line: operation value from the Ternary Raster Operation enumeration ([MS-WMF] section 2.1.1.31). wasn't a variable thing
Line: This code defines how to combine the background color data of the source and destination wasn't a variable thing
Line: bitmaps and brush pattern. wasn't a variable thing
Line: ForegroundROP3 (1 byte): The unsigned, most-significant 8 bits of a 24-bit ternary raster wasn't a variable thing
Line: operation value from the Ternary Raster Operation enumeration. This code defines how to wasn't a variable thing
Line: combine the foreground color data of the source and destination bitmaps and brush pattern. wasn't a variable thing
Here is a field: xSrc
Line index: 3956
Line: source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 3958
Line: source rectangle. wasn't a variable thing
Here is a field: XformSrc
Line index: 3960
Here is a field: BkColorSrc
Line index: 3961
Line: color of the source bitmap. wasn't a variable thing
Here is a field: UsageSrc
Line index: 3963
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Line: 87 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: offBmiSrc
Line index: 3970
Line: record to the source bitmap header in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 3972
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 3974
Line: record to the source bitmap bits in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 3976
Here is a field: xMask
Line index: 3977
Line: the mask bitmap. wasn't a variable thing
Here is a field: yMask
Line index: 3979
Line: the mask bitmap. wasn't a variable thing
Here is a field: UsageMask
Line index: 3981
Line: the mask bitmap header. This value is in the DIBColors enumeration. wasn't a variable thing
Here is a field: offBmiMask
Line index: 3983
Line: record to the mask bitmap header in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBmiMask
Line index: 3985
Line: header. wasn't a variable thing
Here is a field: offBitsMask
Line index: 3987
Line: record to the mask bitmap bits in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBitsMask
Line index: 3989
Line: BitmapBuffer (variable): A buffer containing the source and mask bitmaps, which are not required WAS a variable thing
Line: to be contiguous with the fixed portion of the EMR_MASKBLT record or with each other. Thus, wasn't a variable thing
Line: fields in this buffer that are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: Note: The source and mask bitmaps can be present in this buffer in any order. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace3 (variable, optional) WAS a variable thing
Line: 88 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: BmiMask (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace4 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsMask (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: BmiMask (variable): The mask bitmap header. WAS a variable thing
Line: BitsMask (variable): The mask bitmap bits. WAS a variable thing
Line: The mask bitmap MUST be monochrome; that is, each pixel value MUST be zero or one. A pixel value wasn't a variable thing
Line: of one in the mask indicates that the color of the corresponding pixel in the source bitmap SHOULD be wasn't a variable thing
Line: copied to the destination. A value of zero in the mask indicates that the destination pixel color wasn't a variable thing
Line: SHOULD NOT be changed. If the mask rectangle is smaller than the source and destination rectangles, wasn't a variable thing
Line: the mask pattern MUST be replicated as necessary. wasn't a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Name: EMR_MASKBLT
has_variable: True
fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '2b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_MASKBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '2b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Bullshit after...
Name: EMR_MASKBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '2b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Line: The EMR_PLGBLT record specifies a block transfer of pixels from a source bitmap to a destination wasn't a variable thing
Line: parallelogram, with the application of a color mask bitmap. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: aptlDest (24 bytes) wasn't a variable thing
Line: 89 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: cxSrc wasn't a variable thing
Line: cySrc wasn't a variable thing
Line: XformSrc (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: BkColorSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: xMask wasn't a variable thing
Line: yMask wasn't a variable thing
Line: UsageMask wasn't a variable thing
Line: offBmiMask wasn't a variable thing
Line: cbBmiMask wasn't a variable thing
Line: offBitsMask wasn't a variable thing
Line: cbBitsMask wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: 90 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4086
Line: 0x0000004F. wasn't a variable thing
Here is a field: Bounds
Line index: 4088
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: aptlDest
Line index: 4092
Line: three corners a parallelogram destination area for the block transfer. wasn't a variable thing
Line: The upper-left corner of the source rectangle is mapped to the first point in this array, the upperright corner to the second point, and the lower-left corner to the third point. The lower-right wasn't a variable thing
Line: corner of the source rectangle is mapped to the implicit fourth point in the parallelogram, which is wasn't a variable thing
Line: computed from the first three points (A, B, and C) by treating them as vectors. wasn't a variable thing
Line: D = B + C A wasn't a variable thing
Here is a field: xSrc
Line index: 4098
Line: source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 4100
Line: source rectangle. wasn't a variable thing
Here is a field: cxSrc
Line index: 4102
Here is a field: cySrc
Line index: 4103
Here is a field: XformSrc
Line index: 4104
Here is a field: BkColorSrc
Line index: 4105
Line: color of the source bitmap. wasn't a variable thing
Here is a field: UsageSrc
Line index: 4107
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: offBmiSrc
Line index: 4109
Line: record to the source bitmap header in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 4111
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 4113
Line: record to the source bitmap bits in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 4115
Here is a field: xMask
Line index: 4116
Line: the mask bitmap. wasn't a variable thing
Here is a field: yMask
Line index: 4118
Line: the mask bitmap. wasn't a variable thing
Here is a field: UsageMask
Line index: 4120
Line: the mask bitmap header. This value is in the DIBColors enumeration. wasn't a variable thing
Line: 91 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: offBmiMask
Line index: 4127
Line: record to the header of the mask bitmap in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBmiMask
Line index: 4129
Line: header. wasn't a variable thing
Here is a field: offBitsMask
Line index: 4131
Line: record to the mask bitmap bits in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBitsMask
Line index: 4133
Line: BitmapBuffer (variable): A buffer containing the source and mask bitmaps, which are not required WAS a variable thing
Line: to be contiguous with the fixed portion of the EMR_PLGBLT record or with each other. Thus, fields wasn't a variable thing
Line: in this buffer that are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: Note: The source and mask bitmaps can be present in this buffer in any order. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace3 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiMask (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace4 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsMask (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: 92 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: BmiMask (variable): The mask bitmap header. WAS a variable thing
Line: BitsMask (variable): The mask bitmap bits. WAS a variable thing
Line: The mask bitmap MUST be monochrome; that is, each pixel value MUST be zero or one. A pixel value wasn't a variable thing
Line: of one in the mask indicates that the color of the corresponding pixel in the source bitmap SHOULD be wasn't a variable thing
Line: copied to the destination. A value of zero in the mask indicates that the destination pixel color wasn't a variable thing
Line: SHOULD NOT be changed. If the mask rectangle is smaller than the source and destination rectangles, wasn't a variable thing
Line: the mask pattern MUST be replicated as necessary. wasn't a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Name: EMR_PLGBLT
has_variable: True
fields: ['Type', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
struct_format: ['4b', '16b', '24b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_PLGBLT
Here is the struct format: ['4b', '16b', '24b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields before: ['Type', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields after: ['Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Bullshit after...
Name: EMR_PLGBLT
Here is the struct format: ['4b', '4b', '16b', '24b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Line: The EMR_SETDIBITSTODEVICE record specifies a block transfer of pixels from specified scanlines of a wasn't a variable thing
Line: source bitmap to a destination rectangle. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: xDest wasn't a variable thing
Line: yDest wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: cxSrc wasn't a variable thing
Line: cySrc wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: 93 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: iStartScan wasn't a variable thing
Line: cScans wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4213
Line: This value is 0x00000050. wasn't a variable thing
Here is a field: Bounds
Line index: 4215
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: xDest
Line index: 4219
Line: the destination rectangle. wasn't a variable thing
Here is a field: yDest
Line index: 4221
Line: the destination rectangle. wasn't a variable thing
Here is a field: xSrc
Line index: 4223
Line: the source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 4225
Line: the source rectangle. wasn't a variable thing
Here is a field: cxSrc
Line index: 4227
Here is a field: cySrc
Line index: 4228
Here is a field: offBmiSrc
Line index: 4229
Line: record to the source bitmap header in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 4231
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 4233
Line: record to the source bitmap bits in the BitmapBuffer field. wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 4235
Here is a field: UsageSrc
Line index: 4236
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: iStartScan
Line index: 4238
Here is a field: cScans
Line index: 4239
Line: BitmapBuffer (variable): A buffer containing the source bitmap, which is not required to be WAS a variable thing
Line: contiguous with the fixed portion of the EMR_SETDIBITSTODEVICE record. Thus, fields in this wasn't a variable thing
Line: buffer that are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: 94 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: This record supports source images in JPEG and PNG format. The Compression field in the source wasn't a variable thing
Line: bitmap header specifies the image format. wasn't a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Name: EMR_SETDIBITSTODEVICE
has_variable: True
fields: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SETDIBITSTODEVICE
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Fields after: ['Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Bullshit after...
Name: EMR_SETDIBITSTODEVICE
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Line: The EMR_STRETCHBLT record specifies a block transfer of pixels from a source bitmap to a wasn't a variable thing
Line: destination rectangle, optionally in combination with a brush pattern, according to a specified raster wasn't a variable thing
Line: operation, stretching or compressing the output to fit the dimensions of the destination, if necessary. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: xDest wasn't a variable thing
Line: 95 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: yDest wasn't a variable thing
Line: cxDest wasn't a variable thing
Line: cyDest wasn't a variable thing
Line: BitBltRasterOperation wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: XformSrc (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: BkColorSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: cxSrc wasn't a variable thing
Line: cySrc wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4312
Line: value is 0x0000004D. wasn't a variable thing
Here is a field: Bounds
Line index: 4314
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: xDest
Line index: 4318
Line: the destination rectangle. wasn't a variable thing
Line: 96 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: yDest
Line index: 4325
Line: the destination rectangle. wasn't a variable thing
Here is a field: cxDest
Line index: 4327
Here is a field: cyDest
Line index: 4328
Here is a field: BitBltRasterOperation
Line index: 4329
Line: code defines how the color data of the source rectangle is to be combined with the color data of wasn't a variable thing
Line: the destination rectangle and optionally a brush pattern, to achieve the final color. wasn't a variable thing
Line: This value is in the Ternary Raster Operation enumeration ([MS-WMF] section 2.1.1.31). wasn't a variable thing
Here is a field: xSrc
Line index: 4333
Line: source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 4335
Line: source rectangle. wasn't a variable thing
Here is a field: XformSrc
Line index: 4337
Here is a field: BkColorSrc
Line index: 4338
Line: color of the source bitmap. wasn't a variable thing
Here is a field: UsageSrc
Line index: 4340
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: offBmiSrc
Line index: 4342
Line: record to the source bitmap header. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 4344
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 4346
Line: record to the source bitmap bits. wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 4348
Here is a field: cxSrc
Line index: 4349
Here is a field: cySrc
Line index: 4350
Line: BitmapBuffer (variable): A buffer containing the source bitmap, which is not required to be WAS a variable thing
Line: contiguous with the fixed portion of the EMR_STRETCHBLT record. Thus, fields in this buffer that wasn't a variable thing
Line: are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: If the raster operation specified by BitBltRasterOperation does not require a source bitmap, the wasn't a variable thing
Line: source bitmap can be omitted. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: 97 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Name: EMR_STRETCHBLT
has_variable: True
fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_STRETCHBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Bullshit after...
Name: EMR_STRETCHBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Line: The EMR_STRETCHDIBITS record specifies a block transfer of pixels from a source bitmap to a wasn't a variable thing
Line: destination rectangle, optionally in combination with a brush pattern, according to a specified raster wasn't a variable thing
Line: operation, stretching or compressing the output to fit the dimensions of the destination, if necessary. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: xDest wasn't a variable thing
Line: yDest wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: cxSrc wasn't a variable thing
Line: cySrc wasn't a variable thing
Line: 98 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: BitBltRasterOperation wasn't a variable thing
Line: cxDest wasn't a variable thing
Line: cyDest wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4418
Line: value is 0x00000051. wasn't a variable thing
Here is a field: Bounds
Line index: 4420
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: xDest
Line index: 4424
Line: the destination rectangle. wasn't a variable thing
Here is a field: yDest
Line index: 4426
Line: the destination rectangle. wasn't a variable thing
Here is a field: xSrc
Line index: 4428
Line: the source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 4430
Line: the source rectangle. wasn't a variable thing
Here is a field: cxSrc
Line index: 4432
Here is a field: cySrc
Line index: 4433
Here is a field: offBmiSrc
Line index: 4434
Line: record to the source bitmap header. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 4436
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 4438
Line: record to the source bitmap bits. wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 4440
Line: 99 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: UsageSrc
Line index: 4446
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: BitBltRasterOperation
Line index: 4448
Line: codes define how the color data of the source rectangle is to be combined with the color data of wasn't a variable thing
Line: the destination rectangle and optionally a brush pattern, to achieve the final color. wasn't a variable thing
Line: This value is in the Ternary Raster Operation enumeration ([MS-WMF] section 2.1.1.31). wasn't a variable thing
Here is a field: cxDest
Line index: 4452
Here is a field: cyDest
Line index: 4453
Line: BitmapBuffer (variable): A buffer containing the source bitmap, which is not required to be WAS a variable thing
Line: contiguous with the fixed portion of the EMR_STRETCHDIBITS record. Thus, fields in this buffer wasn't a variable thing
Line: that are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: If the raster operation specified by BitBltRasterOperation does not require a source bitmap, the wasn't a variable thing
Line: source bitmap can be omitted. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: This record supports source images in JPEG and PNG formats. The Compression field in the source wasn't a variable thing
Line: bitmap header specifies the image format. wasn't a variable thing
Line: If the signs of the source and destination height and width fields differ, this record specifies a mirrorimage copy of the source bitmap to the destination. That is, if cxSrc and cxDest have different signs, wasn't a variable thing
Line: a mirror image of the source bitmap along the x-axis is specified. If cySrc and cyDest have different wasn't a variable thing
Line: signs, a mirror image of the source bitmap along the y-axis is specified. wasn't a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Line: 100 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_STRETCHDIBITS
has_variable: True
fields: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_STRETCHDIBITS
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Fields after: ['Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Bullshit after...
Name: EMR_STRETCHDIBITS
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Line: The EMR_TRANSPARENTBLT record specifies a block transfer of pixels from a source bitmap to a wasn't a variable thing
Line: destination rectangle, treating a specified color as transparent, stretching or compressing the output wasn't a variable thing
Line: to fit the dimensions of the destination, if necessary.<58> wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: xDest wasn't a variable thing
Line: yDest wasn't a variable thing
Line: cxDest wasn't a variable thing
Line: cyDest wasn't a variable thing
Line: TransparentColor wasn't a variable thing
Line: xSrc wasn't a variable thing
Line: ySrc wasn't a variable thing
Line: XformSrc (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: BkColorSrc wasn't a variable thing
Line: UsageSrc wasn't a variable thing
Line: offBmiSrc wasn't a variable thing
Line: 101 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: cbBmiSrc wasn't a variable thing
Line: offBitsSrc wasn't a variable thing
Line: cbBitsSrc wasn't a variable thing
Line: cxSrc wasn't a variable thing
Line: cySrc wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4531
Line: This value is 0x00000074. wasn't a variable thing
Here is a field: Bounds
Line index: 4533
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping regions (section 3.1.1.2.1) in the playback device context (section 3.1) is empty, this wasn't a variable thing
Line: record has no effect. wasn't a variable thing
Here is a field: xDest
Line index: 4537
Line: the destination rectangle. wasn't a variable thing
Here is a field: yDest
Line index: 4539
Line: the destination rectangle. wasn't a variable thing
Here is a field: cxDest
Line index: 4541
Here is a field: cyDest
Line index: 4542
Here is a field: TransparentColor
Line index: 4543
Line: in the source bitmap to be treated as transparent. wasn't a variable thing
Here is a field: xSrc
Line index: 4545
Line: source rectangle. wasn't a variable thing
Here is a field: ySrc
Line index: 4547
Line: source rectangle. wasn't a variable thing
Here is a field: XformSrc
Line index: 4549
Here is a field: BkColorSrc
Line index: 4550
Here is a field: UsageSrc
Line index: 4551
Line: the source bitmap header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: offBmiSrc
Line index: 4553
Line: record to the source bitmap header. wasn't a variable thing
Here is a field: cbBmiSrc
Line index: 4555
Line: header. wasn't a variable thing
Here is a field: offBitsSrc
Line index: 4557
Line: record to the source bitmap bits. wasn't a variable thing
Line: 102 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: cbBitsSrc
Line index: 4564
Here is a field: cxSrc
Line index: 4565
Here is a field: cySrc
Line index: 4566
Line: BitmapBuffer (variable): A buffer containing the source bitmap, which is not required to be WAS a variable thing
Line: contiguous with the fixed portion of the EMR_TRANSPARENTBLT record. Thus, fields in this buffer wasn't a variable thing
Line: that are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: If the source bitmap color format is 32 bits-per-pixel, only the alpha transparency value in each wasn't a variable thing
Line: pixel SHOULD be copied to the destination.<59> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable): The source bitmap header. WAS a variable thing
Line: BitsSrc (variable): The source bitmap bits. WAS a variable thing
Line: See section 2.3.1 for more bitmap record types. wasn't a variable thing
Line: 2.3.2 Clipping Record Types wasn't a variable thing
Line: The Clipping record types define and manage clipping regions. The clipping regions used by clipping wasn't a variable thing
Line: record types are part of the Regions state element (section 3.1.1.2.1) in the playback device wasn't a variable thing
Line: context (section 3.1). wasn't a variable thing
Line: Note: The EMR_SETMETARGN record does not specify parameters. wasn't a variable thing
Line: The following are the clipping record types. wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_EXCLUDECLIPRECT 2.3.2.1 Specifies a clipping region that consists of the current clipping region wasn't a variable thing
Line: minus the specified rectangle. wasn't a variable thing
Line: EMR_EXTSELECTCLIPRGN 2.3.2.2 Combines the specified region with the current clipping region, using the wasn't a variable thing
Line: specified mode. wasn't a variable thing
Line: 103 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_INTERSECTCLIPRECT 2.3.2.3 Specifies a clipping region from the intersection of the current clipping wasn't a variable thing
Line: region and the specified rectangle. wasn't a variable thing
Line: EMR_OFFSETCLIPRGN 2.3.2.4 Specifies a clipping region as the current clipping region moved by a wasn't a variable thing
Line: specified offset. wasn't a variable thing
Line: EMR_SELECTCLIPPATH 2.3.2.5 Specifies a clipping region as the current clipping region combined with wasn't a variable thing
Line: the current path bracket, using the specified mode. wasn't a variable thing
Line: EMR_SETMETARGN 2.3.2 If the current metaregion is null, it is set to the current clipping region. wasn't a variable thing
Line: Otherwise, the current metaregion is intersected with the current clipping wasn't a variable thing
Line: region, and the result is the new metaregion. wasn't a variable thing
Line: After the operation, the current clipping region is set to null. wasn't a variable thing
Line: During playback, drawing occurs only within the intersection of the wasn't a variable thing
Line: metaregion and clipping region. wasn't a variable thing
Line: This EMF record specifies no parameters. wasn't a variable thing
Line: The generic structure of clipping records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ClippingRecordBuffer (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Name: EMR_TRANSPARENTBLT
has_variable: True
fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_TRANSPARENTBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Bullshit after...
Name: EMR_TRANSPARENTBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Line: The EMR_EXCLUDECLIPRECT record excludes the specified rectangle from the current clipping wasn't a variable thing
Line: region. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.2. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Clip wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4684
Line: value is 0x0000001D. wasn't a variable thing
Here is a field: Clip
Line index: 4686
Line: units. wasn't a variable thing
Line: The result of the intersection is saved as the new current clipping region. The lower and right edges of wasn't a variable thing
Line: the specified rectangle MUST NOT be excluded from clipping. wasn't a variable thing
Line: See section 2.3.2 for more clipping record types. wasn't a variable thing
Line: 105 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_EXCLUDECLIPRECT
has_variable: False
fields: ['Type', 'Clip']
struct_format: ['4b', '16b']
Bullshit before...
Name: EMR_EXCLUDECLIPRECT
Here is the struct format: ['4b', '16b']
Here is the fields: ['Type', 'Clip']
Fields before: ['Type', 'Clip']
Fields after: ['Clip']
Bullshit after...
Name: EMR_EXCLUDECLIPRECT
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Clip']
Line: The EMR_EXTSELECTCLIPRGN record combines the specified region with the current clipping region wasn't a variable thing
Line: using the specified mode. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.2. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: RgnDataSize wasn't a variable thing
Line: RegionMode wasn't a variable thing
Line: RgnData (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4713
Line: This value is 0x0000004B. wasn't a variable thing
Here is a field: RgnDataSize
Line index: 4715
Here is a field: RegionMode
Line index: 4716
Line: the RegionMode (section 2.1.29) enumeration. wasn't a variable thing
Line: RgnData (variable): An array of bytes that specifies a RegionData object (section 2.2.24) in logical WAS a variable thing
Line: units. If RegionMode is RGN_COPY, this data can be omitted and the clipping region SHOULD be wasn't a variable thing
Line: set to the default clipping region. wasn't a variable thing
Line: See section 2.3.2 for more clipping record types. wasn't a variable thing
Name: EMR_EXTSELECTCLIPRGN
has_variable: True
fields: ['Type', 'RgnDataSize', 'RegionMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_EXTSELECTCLIPRGN
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'RgnDataSize', 'RegionMode']
Fields before: ['Type', 'RgnDataSize', 'RegionMode']
Fields after: ['RgnDataSize', 'RegionMode']
Bullshit after...
Name: EMR_EXTSELECTCLIPRGN
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'RgnDataSize', 'RegionMode']
Line: The EMR_INTERSECTCLIPRECT record specifies a new clipping region from the intersection of the wasn't a variable thing
Line: current clipping region and the specified rectangle. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.2. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Clip wasn't a variable thing
Line: ... wasn't a variable thing
Line: 106 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4744
Line: This value is 0x0000001E. wasn't a variable thing
Here is a field: Clip
Line index: 4746
Line: units. wasn't a variable thing
Line: The lower and right edges of the specified rectangle are excluded from the clipping region. wasn't a variable thing
Line: See section 2.3.2 for more clipping record types. wasn't a variable thing
Name: EMR_INTERSECTCLIPRECT
has_variable: False
fields: ['Type', 'Clip']
struct_format: ['4b', '16b']
Bullshit before...
Name: EMR_INTERSECTCLIPRECT
Here is the struct format: ['4b', '16b']
Here is the fields: ['Type', 'Clip']
Fields before: ['Type', 'Clip']
Fields after: ['Clip']
Bullshit after...
Name: EMR_INTERSECTCLIPRECT
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Clip']
Line: The EMR_OFFSETCLIPRGN record moves the current clipping region in the playback device context wasn't a variable thing
Line: by the specified offsets. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.2. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Offset wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 4765
Line: value is 0x0000001A. wasn't a variable thing
Here is a field: Offset
Line index: 4767
Line: vertical offsets in logical units. wasn't a variable thing
Line: See section 2.3.2 for more clipping record types. wasn't a variable thing
Name: EMR_OFFSETCLIPRGN
has_variable: False
fields: ['Type', 'Offset']
struct_format: ['4b', '8b']
Bullshit before...
Name: EMR_OFFSETCLIPRGN
Here is the struct format: ['4b', '8b']
Here is the fields: ['Type', 'Offset']
Fields before: ['Type', 'Offset']
Fields after: ['Offset']
Bullshit after...
Name: EMR_OFFSETCLIPRGN
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Offset']
Line: The EMR_SELECTCLIPPATH record sets the current clipping region in the playback device wasn't a variable thing
Line: context to the current clipping region combined with current path bracket. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.2. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: 107 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: RegionMode wasn't a variable thing
Here is a field: Type
Line index: 4789
Line: value is 0x00000043. wasn't a variable thing
Here is a field: RegionMode
Line index: 4791
Line: region with the current path bracket. This value is in the RegionMode enumeration (section wasn't a variable thing
Line: 2.1.29). wasn't a variable thing
Line: See section 2.3.2 for more clipping record types. wasn't a variable thing
Line: 2.3.3 Comment Record Types wasn't a variable thing
Line: The Comment record types define formats for specifying arbitrary private data, embedding records in wasn't a variable thing
Line: other metafile formats, and adding new or special-purpose commands. wasn't a variable thing
Line: The following are EMF comment record types. wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_COMMENT 2.3.3.1 Contains arbitrary private data. wasn't a variable thing
Line: EMR_COMMENT_EMFPLUS 2.3.3.2 Contains embedded EMF+ records ([MS-EMFPLUS] section 2.3). wasn't a variable thing
Line: EMR_COMMENT_EMFSPOOL 2.3.3.3 Contains embedded EMFSPOOL records ([MS-EMFSPOOL] section 2.2). wasn't a variable thing
Line: EMR_COMMENT_PUBLIC 2.3.3.4 Specifies extensions to EMF processing. wasn't a variable thing
Line: The generic structure of comment records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: DataSize wasn't a variable thing
Line: CommentRecordBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Name: EMR_SELECTCLIPPATH
has_variable: True
fields: ['Type', 'RegionMode']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_SELECTCLIPPATH
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'RegionMode']
Fields before: ['Type', 'RegionMode']
Fields after: ['RegionMode']
Bullshit after...
Name: EMR_SELECTCLIPPATH
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'RegionMode']
Line: The EMR_COMMENT record contains arbitrary private data. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.3. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: DataSize wasn't a variable thing
Line: PrivateData (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: 109 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: PrivateData (variable, optional): An array of bytes that specifies the private data. The first 32-bit WAS a variable thing
Line: field of this data MUST NOT be one of the predefined comment identifier values specified in section wasn't a variable thing
Line: 2.3.3. wasn't a variable thing
Line: Private data is unknown to EMF; it is meaningful only to applications that know the format of the data wasn't a variable thing
Line: and how to use it. EMR_COMMENT private data records MAY<60> be ignored. wasn't a variable thing
Line: See section 2.3.3 for more comment record types. wasn't a variable thing
Name: EMR_COMMENT
has_variable: True
fields: []
struct_format: []
Bullshit before...
Name: EMR_COMMENT
Here is the struct format: []
Here is the fields: []
Fields before: []
Fields after: []
Bullshit after...
Name: EMR_COMMENT
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'Size']
Line: The EMR_COMMENT_EMFPLUS record contains embedded EMF+ records ([MS-EMFPLUS] section wasn't a variable thing
Line: 2.3). wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.3. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: DataSize wasn't a variable thing
Line: CommentIdentifier wasn't a variable thing
Line: EMFPlusRecords (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: CommentIdentifier
Line index: 4899
Line: containing EMF+ records. The value 0x2B464D45, which is the ASCII string "+FME", identifies wasn't a variable thing
Line: this as an EMR_COMMENT_EMFPLUS record. wasn't a variable thing
Line: EMFPlusRecords (variable): An array of bytes that contains one or more EMF+ records. WAS a variable thing
Line: See section 2.3.3 for more comment record types. wasn't a variable thing
Name: EMR_COMMENT_EMFPLUS
has_variable: True
fields: ['CommentIdentifier']
struct_format: ['4b']
Bullshit before...
Name: EMR_COMMENT_EMFPLUS
Here is the struct format: ['4b']
Here is the fields: ['CommentIdentifier']
Fields before: ['CommentIdentifier']
Fields after: ['CommentIdentifier']
Bullshit after...
Name: EMR_COMMENT_EMFPLUS
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'CommentIdentifier']
Line: The EMR_COMMENT_EMFSPOOL record contains embedded EMFSPOOL records ([MS-EMFSPOOL] wasn't a variable thing
Line: section 2.2). wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.3. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: DataSize wasn't a variable thing
Line: 110 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: CommentIdentifier wasn't a variable thing
Line: EMFSpoolRecordIdentifier wasn't a variable thing
Line: EMFSpoolRecords (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: CommentIdentifier
Line index: 4927
Line: containing EMFSPOOL records. The value 0x00000000 identifies this as an wasn't a variable thing
Line: EMR_COMMENT_EMFSPOOL record. wasn't a variable thing
Here is a field: EMFSpoolRecordIdentifier
Line index: 4930
Line: EMR_COMMENT_EMFSPOOL record. The value 0x544F4E46, which is the ASCII string "TONE", wasn't a variable thing
Line: identifies this as an EMFSPOOL font definition record ([MS-EMFSPOOL] section 2.2.3.3). wasn't a variable thing
Line: EMFSpoolRecords (variable): An array of bytes that contain one or more font definition records. WAS a variable thing
Line: See section 2.3.3 for more comment record types. wasn't a variable thing
Not in record.
Previous record name: EMR_COMMENT_EMFSPOOL
Name: EMR_COMMENT_EMFSPOOL
has_variable: True
fields: ['CommentIdentifier', 'EMFSpoolRecordIdentifier']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_COMMENT_EMFSPOOL
Here is the struct format: ['4b', '4b']
Here is the fields: ['CommentIdentifier', 'EMFSpoolRecordIdentifier']
Fields before: ['CommentIdentifier', 'EMFSpoolRecordIdentifier']
Fields after: ['CommentIdentifier', 'EMFSpoolRecordIdentifier']
Bullshit after...
Name: EMR_COMMENT_EMFSPOOL
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'CommentIdentifier', 'EMFSpoolRecordIdentifier']
Line: The EMR_EOF record indicates the end of the metafile and specifies a palette. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.4. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: nPalEntries wasn't a variable thing
Line: offPalEntries wasn't a variable thing
Line: PaletteBuffer (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: SizeLast wasn't a variable thing
Here is a field: Type
Line index: 5205
Line: 0x0000000E. wasn't a variable thing
Here is a field: nPalEntries
Line index: 5207
Here is a field: offPalEntries
Line index: 5208
Line: start of this record. wasn't a variable thing
Line: PaletteBuffer (variable, optional): An array of bytes that contains palette data, which is not WAS a variable thing
Line: required to be contiguous with the fixed-length portion of the EMR_EOF record. Thus, fields in this wasn't a variable thing
Line: buffer that are labeled "UndefinedSpace" are optional and MUST be ignored. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace1 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: 117 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: PaletteEntries (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace2 (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: PaletteEntries (variable): An array of LogPaletteEntry objects (section 2.2.18) that specifies the WAS a variable thing
Line: palette data. wasn't a variable thing
Here is a field: SizeLast
Line index: 5233
Line: of the record and hence the metafile. LogPaletteEntry objects, if they exist, MUST precede this wasn't a variable thing
Line: field. wasn't a variable thing
Line: See section 2.3.4 for more control record types. wasn't a variable thing
Not in record.
Previous record name: EMR_EOF
Name: EMR_EOF
has_variable: True
fields: ['Type', 'nPalEntries', 'offPalEntries', 'SizeLast']
struct_format: ['4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_EOF
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'nPalEntries', 'offPalEntries', 'SizeLast']
Fields before: ['Type', 'nPalEntries', 'offPalEntries', 'SizeLast']
Fields after: ['nPalEntries', 'offPalEntries', 'SizeLast']
Bullshit after...
Name: EMR_EOF
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'nPalEntries', 'offPalEntries', 'SizeLast']
Line: The EMR_ANGLEARC record specifies a line segment of an arc. The line segment is drawn from the wasn't a variable thing
Line: current position to the beginning of the arc. The arc is drawn along the perimeter of a circle with the wasn't a variable thing
Line: given radius and center. The length of the arc is defined by the given start and sweep angles. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Center wasn't a variable thing
Line: ... wasn't a variable thing
Line: Radius wasn't a variable thing
Line: StartAngle wasn't a variable thing
Line: SweepAngle wasn't a variable thing
Here is a field: Type
Line index: 5708
Line: is 0x00000029. wasn't a variable thing
Here is a field: Size
Line index: 5710
Here is a field: Center
Line index: 5711
Line: coordinates of the circle's center. wasn't a variable thing
Here is a field: Radius
Line index: 5713
Line: 129 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: StartAngle
Line index: 5719
Here is a field: SweepAngle
Line index: 5720
Line: The arc is drawn by recording an imaginary circle around the specified center point with the specified wasn't a variable thing
Line: radius. The starting point of the arc is determined by measuring counterclockwise from the x-axis of wasn't a variable thing
Line: the circle by the number of degrees in the start angle. The ending point is similarly located by wasn't a variable thing
Line: measuring counterclockwise from the starting point by the number of degrees in the sweep angle. wasn't a variable thing
Line: If the sweep angle is greater than 360 degrees, the arc is swept multiple times. wasn't a variable thing
Line: This record specifies lines by using the current pen. The figure is not filled. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_ANGLEARC
has_variable: False
fields: ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle']
struct_format: ['4b', '4b', '8b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_ANGLEARC
Here is the struct format: ['4b', '4b', '8b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle']
Fields before: ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle']
Fields after: ['Center', 'Radius', 'StartAngle', 'SweepAngle']
Bullshit after...
Name: EMR_ANGLEARC
Here is the struct format: ['4b', '4b', '8b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle']
Line: The EMR_ARC record specifies an elliptical arc. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Box wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Start wasn't a variable thing
Line: ... wasn't a variable thing
Line: End wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 5747
Line: 0x0000002D. wasn't a variable thing
Here is a field: Size
Line index: 5749
Here is a field: Box
Line index: 5750
Here is a field: Start
Line index: 5751
Line: logical units of the ending point of the radial line defining the starting point of the arc. wasn't a variable thing
Here is a field: End
Line index: 5753
Line: radial line defining the ending point of the arc. wasn't a variable thing
Line: 130 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_ARC
has_variable: False
fields: ['Type', 'Size', 'Box', 'Start', 'End']
struct_format: ['4b', '4b', '16b', '8b', '8b']
Bullshit before...
Name: EMR_ARC
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_ARC
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Line: The EMR_ARCTO record specifies an elliptical arc. It resets the current drawing position to the wasn't a variable thing
Line: endpoint of the arc. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Box wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Start wasn't a variable thing
Line: ... wasn't a variable thing
Line: End wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 5781
Line: 0x00000037. wasn't a variable thing
Here is a field: Size
Line index: 5783
Here is a field: Box
Line index: 5784
Here is a field: Start
Line index: 5785
Line: logical units, of the first radial ending point, in logical units. wasn't a variable thing
Here is a field: End
Line index: 5787
Line: logical units. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_ARCTO
has_variable: False
fields: ['Type', 'Size', 'Box', 'Start', 'End']
struct_format: ['4b', '4b', '16b', '8b', '8b']
Bullshit before...
Name: EMR_ARCTO
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_ARCTO
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Line: The EMR_CHORD record specifies a chord, which is a region bounded by the intersection of an ellipse wasn't a variable thing
Line: and a line segment, called a secant. The chord is outlined by using the current pen and filled by using wasn't a variable thing
Line: the current brush. wasn't a variable thing
Line: 131 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Box wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Start wasn't a variable thing
Line: ... wasn't a variable thing
Line: End wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 5816
Line: 0x0000002E. wasn't a variable thing
Here is a field: Size
Line index: 5818
Here is a field: Box
Line index: 5819
Here is a field: Start
Line index: 5820
Line: logical units, of the endpoint of the radial defining the beginning of the chord. wasn't a variable thing
Here is a field: End
Line index: 5822
Line: defining the end of the chord. wasn't a variable thing
Line: The curve of the chord is defined by an ellipse that fits the specified bounding rectangle. The curve wasn't a variable thing
Line: begins at the point where the ellipse intersects the first radial and extends counterclockwise to the wasn't a variable thing
Line: point where the ellipse intersects the second radial. The chord is closed by drawing a line from the wasn't a variable thing
Line: intersection of the first radial and the curve to the intersection of the second radial and the curve. wasn't a variable thing
Line: If the starting point and ending point of the curve are the same, a complete ellipse is drawn. wasn't a variable thing
Line: The current drawing position is neither used nor updated by processing this record. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_CHORD
has_variable: False
fields: ['Type', 'Size', 'Box', 'Start', 'End']
struct_format: ['4b', '4b', '16b', '8b', '8b']
Bullshit before...
Name: EMR_CHORD
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_CHORD
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Line: The EMR_ELLIPSE record specifies an ellipse. The center of the ellipse is the center of the specified wasn't a variable thing
Line: bounding rectangle. The ellipse is outlined by using the current pen and is filled by using the current wasn't a variable thing
Line: brush. wasn't a variable thing
Line: 132 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Box wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 5853
Line: 0x0000002A. wasn't a variable thing
Here is a field: Size
Line index: 5855
Here is a field: Box
Line index: 5856
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_ELLIPSE
has_variable: False
fields: ['Type', 'Size', 'Box']
struct_format: ['4b', '4b', '16b']
Bullshit before...
Name: EMR_ELLIPSE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Fields before: ['Type', 'Size', 'Box']
Fields after: ['Box']
Bullshit after...
Name: EMR_ELLIPSE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Line: The EMR_EXTFLOODFILL record fills an area of the display surface with the current brush. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Start wasn't a variable thing
Line: ... wasn't a variable thing
Line: Color wasn't a variable thing
Line: FloodFillMode wasn't a variable thing
Here is a field: Type
Line index: 5873
Line: value is 0x00000035. wasn't a variable thing
Here is a field: Size
Line index: 5875
Here is a field: Start
Line index: 5876
Line: logical units, where filling begins. wasn't a variable thing
Here is a field: Color
Line index: 5878
Line: FloodFillMode to determine the area to fill. wasn't a variable thing
Line: 133 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: FloodFillMode
Line index: 5885
Line: determine the area for the flood fill operation. This value is in the FloodFill enumeration (section wasn't a variable thing
Line: 2.1.13). wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_EXTFLOODFILL
has_variable: False
fields: ['Type', 'Size', 'Start', 'Color', 'FloodFillMode']
struct_format: ['4b', '4b', '8b', '4b', '4b']
Bullshit before...
Name: EMR_EXTFLOODFILL
Here is the struct format: ['4b', '4b', '8b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Start', 'Color', 'FloodFillMode']
Fields before: ['Type', 'Size', 'Start', 'Color', 'FloodFillMode']
Fields after: ['Start', 'Color', 'FloodFillMode']
Bullshit after...
Name: EMR_EXTFLOODFILL
Here is the struct format: ['4b', '4b', '8b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Start', 'Color', 'FloodFillMode']
Line: The EMR_EXTTEXTOUTA record draws an ASCII text string using the current font and text colors. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.5. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: iGraphicsMode wasn't a variable thing
Line: exScale wasn't a variable thing
Line: eyScale wasn't a variable thing
Line: aEmrText (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 5910
Line: RecordType enumeration (section 2.1.1). This value is 0x00000053. wasn't a variable thing
Here is a field: Bounds
Line index: 5912
Line: ignored on receipt. wasn't a variable thing
Here is a field: iGraphicsMode
Line index: 5914
Line: GraphicsMode enumeration (section 2.1.16). wasn't a variable thing
Here is a field: exScale
Line index: 5916
Line: from page space units to .01mm units. This SHOULD be used only if the graphics mode specified wasn't a variable thing
Line: by iGraphicsMode is GM_COMPATIBLE. wasn't a variable thing
Here is a field: eyScale
Line index: 5919
Line: from page space units to .01mm units. This SHOULD be used only if the graphics mode specified wasn't a variable thing
Line: by iGraphicsMode is GM_COMPATIBLE. wasn't a variable thing
Line: 134 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: aEmrText (variable): An EmrText object (section 2.2.5) that specifies the output string in 8-bit WAS a variable thing
Line: ASCII characters, text attributes, and spacing values. wasn't a variable thing
Line: The font and text colors used for output are specified by the state of the current graphics environment wasn't a variable thing
Line: (section 3.1.1.2). A rectangle for clipping and/or opaquing can be defined in the EmrText object in the wasn't a variable thing
Line: aEmrText field. wasn't a variable thing
Line: This record SHOULD<64> be emulated with an EMR_EXTTEXTOUTW record (section 2.3.5.8), which wasn't a variable thing
Line: requires the ASCII text string in the EmrText object to be converted to Unicode UTF16-LE encoding. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_EXTTEXTOUTA
has_variable: True
fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
struct_format: ['4b', '16b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_EXTTEXTOUTA
Here is the struct format: ['4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Bullshit after...
Name: EMR_EXTTEXTOUTA
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Line: The EMR_EXTTEXTOUTW record draws a Unicode text string using the current font and text colors. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.5. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: iGraphicsMode wasn't a variable thing
Line: exScale wasn't a variable thing
Line: eyScale wasn't a variable thing
Line: wEmrText (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 5956
Line: the RecordType enumeration (section 2.1.1). This value is 0x00000054. wasn't a variable thing
Here is a field: Bounds
Line index: 5958
Line: on receipt. wasn't a variable thing
Here is a field: iGraphicsMode
Line index: 5960
Line: GraphicsMode enumeration (section 2.1.16). wasn't a variable thing
Here is a field: exScale
Line index: 5962
Line: from page space units to .01mm units. This is used only if the graphics mode specified by wasn't a variable thing
Line: iGraphicsMode is GM_COMPATIBLE. wasn't a variable thing
Line: 135 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: eyScale
Line index: 5970
Line: from page space units to .01mm units. This is used only if the graphics mode specified by wasn't a variable thing
Line: iGraphicsMode is GM_COMPATIBLE. wasn't a variable thing
Line: wEmrText (variable): An EmrText object (section 2.2.5) that specifies the output string in Unicode WAS a variable thing
Line: UTF16-LE characters, with text attributes and spacing values. wasn't a variable thing
Line: The font and text colors used for output are specified by properties in the current state of EMF wasn't a variable thing
Line: metafile playback (section 3.1). A rectangle for clipping and/or opaquing can be defined in the wasn't a variable thing
Line: EmrText object that is specified in the aEmrText field. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_EXTTEXTOUTW
has_variable: True
fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
struct_format: ['4b', '16b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_EXTTEXTOUTW
Here is the struct format: ['4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Bullshit after...
Name: EMR_EXTTEXTOUTW
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Line: The EMR_FILLPATH record closes any open figures in the current path bracket and fills the path's wasn't a variable thing
Line: interior by using the current brush and polygon-filling mode. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 5995
Line: is 0x0000003E. wasn't a variable thing
Here is a field: Size
Line index: 5997
Here is a field: Bounds
Line index: 5998
Line: rectangle in logical units. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_FILLPATH
has_variable: False
fields: ['Type', 'Size', 'Bounds']
struct_format: ['4b', '4b', '16b']
Bullshit before...
Name: EMR_FILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Fields before: ['Type', 'Size', 'Bounds']
Fields after: ['Bounds']
Bullshit after...
Name: EMR_FILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Line: The EMR_FILLRGN record fills the specified region by using the specified brush. The current clipping wasn't a variable thing
Line: regions used by this record are maintained in a Regions state element (section 3.1.1.2.1) in the wasn't a variable thing
Line: playback device context (section 3.1). wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: 136 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: RgnDataSize wasn't a variable thing
Line: ihBrush wasn't a variable thing
Line: RgnData (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6027
Line: 0x00000047. wasn't a variable thing
Here is a field: Size
Line index: 6029
Here is a field: Bounds
Line index: 6030
Line: bounding rectangle in logical units. If the intersection of this rectangle with the current clipping wasn't a variable thing
Line: region is empty, this record has no effect. wasn't a variable thing
Here is a field: RgnDataSize
Line index: 6033
Here is a field: ihBrush
Line index: 6034
Line: (section 3.1.1.1) for filling the region. wasn't a variable thing
Line: RgnData (variable): A RgnDataSize length array of bytes that specifies the output region in a WAS a variable thing
Line: RegionData object (section 2.2.24). The bounds specified by the RegionDataHeader field of wasn't a variable thing
Line: this object MAY<65> be used as the bounding region when this record is processed. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_FILLRGN
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush']
struct_format: ['4b', '4b', '16b', '4b', '4b']
Bullshit before...
Name: EMR_FILLRGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush']
Fields after: ['Bounds', 'RgnDataSize', 'ihBrush']
Bullshit after...
Name: EMR_FILLRGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush']
Line: The EMR_FRAMERGN record draws a border around the specified region using the specified brush. wasn't a variable thing
Line: The current clipping regions used by this record are maintained in a Regions state element (section wasn't a variable thing
Line: 3.1.1.2.1) in the playback device context (section 3.1). wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: 137 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: RgnDataSize wasn't a variable thing
Line: ihBrush wasn't a variable thing
Line: Width wasn't a variable thing
Line: Height wasn't a variable thing
Line: RgnData (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6068
Line: is 0x00000048. wasn't a variable thing
Here is a field: Size
Line index: 6070
Here is a field: Bounds
Line index: 6071
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping region is empty, this record has no effect. wasn't a variable thing
Here is a field: RgnDataSize
Line index: 6074
Here is a field: ihBrush
Line index: 6075
Line: index. wasn't a variable thing
Here is a field: Width
Line index: 6077
Line: units. wasn't a variable thing
Here is a field: Height
Line index: 6079
Line: units. wasn't a variable thing
Line: RgnData (variable): A RgnDataSize length array of bytes that specifies the output region in a WAS a variable thing
Line: RegionData object (section 2.2.24). The bounds specified by the RegionDataHeader field of wasn't a variable thing
Line: this object MAY<66> be used as the bounding region when this record is processed. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_FRAMERGN
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
struct_format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_FRAMERGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Fields after: ['Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Bullshit after...
Name: EMR_FRAMERGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Line: The EMR_GRADIENTFILL record specifies filling rectangles or triangles with gradients of color.<67> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: 138 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: nVer wasn't a variable thing
Line: nTri wasn't a variable thing
Line: ulMode wasn't a variable thing
Line: VertexData (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6110
Line: value is 0x00000076. wasn't a variable thing
Here is a field: Size
Line index: 6112
Here is a field: Bounds
Line index: 6113
Here is a field: nVer
Line index: 6114
Here is a field: nTri
Line index: 6115
Here is a field: ulMode
Line index: 6116
Line: GradientFill enumeration (section 2.1.15). wasn't a variable thing
Line: VertexData (variable): Objects that specify the vertexes of either rectangles or triangles and the WAS a variable thing
Line: colors that correspond to them. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: VertexObjects (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: VertexIndexes (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: VertexPadding (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: VertexObjects (variable): An array of nVer TriVertex objects (section 2.2.26). Each object WAS a variable thing
Line: specifies the position and color of a vertex of either a rectangle or a triangle, depending on the wasn't a variable thing
Line: value of the ulMode field. wasn't a variable thing
Line: 139 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: VertexIndexes (variable): An array of nTri GradientRectangle objects (section 2.2.7) or WAS a variable thing
Line: GradientTriangle objects (section 2.2.8), depending on the value of the ulMode field. Each wasn't a variable thing
Line: object specifies indexes into the array of TriVertex objects in the VertexObjects field. wasn't a variable thing
Line: VertexPadding (variable, optional): An array of nTri times four bytes that MUST be present if WAS a variable thing
Line: the value of the ulMode field indicates GradientRectangle objects (section 2.2.7). If the value wasn't a variable thing
Line: of the ulMode field indicates GradientTriangle objects (section 2.2.8), no VertexPadding is wasn't a variable thing
Line: present. This field MUST be ignored. wasn't a variable thing
Line: An EMR_GRADIENTFILL record that specifies that the three vertexes of a triangle SHOULD fill the wasn't a variable thing
Line: figure with smooth gradients of colors.<68> wasn't a variable thing
Line: An EMR_GRADIENTFILL record that specifies that the upper-left and lower-right vertexes of a wasn't a variable thing
Line: rectangle SHOULD fill the figure with smooth gradients of color. There are two gradient fill modes in wasn't a variable thing
Line: the GradientFill enumeration that can be used when drawing a rectangle. In wasn't a variable thing
Line: GRADIENT_FILL_RECT_H mode, the rectangle is filled from left to right. In wasn't a variable thing
Line: GRADIENT_FILL_RECT_V mode, the rectangle is filled from top to bottom. wasn't a variable thing
Line: An EMR_GRADIENTFILL record MUST ignore the Alpha fields in the TriVertex objects. An wasn't a variable thing
Line: EMR_ALPHABLEND record (section 2.3.1.1) that immediately follows the EMR_GRADIENTFILL record wasn't a variable thing
Line: can be used to apply an alpha transparency gradient to the filled area. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_GRADIENTFILL
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode']
struct_format: ['4b', '4b', '16b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_GRADIENTFILL
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode']
Fields before: ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode']
Fields after: ['Bounds', 'nVer', 'nTri', 'ulMode']
Bullshit after...
Name: EMR_GRADIENTFILL
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode']
Line: The EMR_LINETO record specifies a line from the current drawing position up to, but not including, the wasn't a variable thing
Line: specified point. It resets the current position to the specified point. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Point wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6173
Line: 0x00000036. wasn't a variable thing
Here is a field: Size
Line index: 6175
Here is a field: Point
Line index: 6176
Line: line's endpoint. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_LINETO
has_variable: False
fields: ['Type', 'Size', 'Point']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_LINETO
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Point']
Fields before: ['Type', 'Size', 'Point']
Fields after: ['Point']
Bullshit after...
Name: EMR_LINETO
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Point']
Line: The EMR_PAINTRGN record paints the specified region by using the current brush. The current wasn't a variable thing
Line: clipping regions used by this record are maintained in a Regions state element (section 3.1.1.2.1) in wasn't a variable thing
Line: the playback device context (section 3.1). wasn't a variable thing
Line: 140 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: RgnDataSize wasn't a variable thing
Line: RgnData (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6204
Line: is 0x0000004A. wasn't a variable thing
Here is a field: Size
Line index: 6206
Here is a field: Bounds
Line index: 6207
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping region is empty, this record has no effect. wasn't a variable thing
Here is a field: RgnDataSize
Line index: 6210
Line: bytes. wasn't a variable thing
Line: RgnData (variable): An array of bytes that specifies the output region in a RegionData object WAS a variable thing
Line: (section 2.2.24). The bounds specified by the RegionDataHeader field of that object MAY<69> wasn't a variable thing
Line: be used as the bounding rectangle of the region when this record is processed. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_PAINTRGN
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_PAINTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields after: ['Bounds', 'RgnDataSize']
Bullshit after...
Name: EMR_PAINTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Line: The EMR_PIE record specifies a pie-shaped wedge bounded by the intersection of an ellipse and two wasn't a variable thing
Line: radials. The pie is outlined by using the current pen and filled by using the current brush. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Box wasn't a variable thing
Line: 141 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Start wasn't a variable thing
Line: ... wasn't a variable thing
Line: End wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6241
Line: 0x0000002F. wasn't a variable thing
Here is a field: Size
Line index: 6243
Here is a field: Box
Line index: 6244
Here is a field: Start
Line index: 6245
Line: logical units, of the endpoint of the first radial. wasn't a variable thing
Here is a field: End
Line index: 6247
Line: second radial. wasn't a variable thing
Line: The curve of the pie is defined by an ellipse that fits the specified bounding rectangle. The curve wasn't a variable thing
Line: begins at the point where the ellipse intersects the first radial and extends counterclockwise to the wasn't a variable thing
Line: point where the ellipse intersects the second radial. wasn't a variable thing
Line: The current drawing position is neither used nor updated by this record. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_PIE
has_variable: False
fields: ['Type', 'Size', 'Box', 'Start', 'End']
struct_format: ['4b', '4b', '16b', '8b', '8b']
Bullshit before...
Name: EMR_PIE
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_PIE
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Line: The EMR_POLYBEZIER record specifies one or more Bezier curves. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: 142 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6277
Line: value is 0x00000002. wasn't a variable thing
Here is a field: Size
Line index: 6279
Here is a field: Bounds
Line index: 6280
Line: rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6282
Line: value MUST be one more than three times the number of curves to be drawn because each Bezier wasn't a variable thing
Line: curve requires two control points and an endpoint, and the initial curve requires an additional wasn't a variable thing
Line: starting point. wasn't a variable thing
Line: Line width Device supports wideline Maximum points allowed wasn't a variable thing
Line: 1 n/a 16K wasn't a variable thing
Line: > 1 yes 16K wasn't a variable thing
Line: > 1 no 1360 wasn't a variable thing
Line: Any extra points MUST be ignored. wasn't a variable thing
Line: aPoints (variable): An array of PointL objects ([MS-WMF] section 2.2.2.15) that specify the WAS a variable thing
Line: endpoints and control points of the Bezier curves in logical units. wasn't a variable thing
Line: Cubic Bezier curves are defined using the endpoints and control points specified by the aPoints field. wasn't a variable thing
Line: The first curve is drawn from the first point to the fourth point, using the second and third points as wasn't a variable thing
Line: control points. Each subsequent curve in the sequence needs exactly three more points: the ending wasn't a variable thing
Line: point of the previous curve is used as the starting point, the next two points in the sequence are wasn't a variable thing
Line: control points, and the third is the ending point. wasn't a variable thing
Line: The cubic Bezier curves SHOULD be drawn using the current pen. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYBEZIER
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYBEZIER
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIER
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYBEZIER16 record specifies one or more Bezier curves. The curves are drawn using the wasn't a variable thing
Line: current pen. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: 143 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6324
Line: value is 0x00000055. wasn't a variable thing
Here is a field: Size
Line index: 6326
Here is a field: Bounds
Line index: 6327
Here is a field: Count
Line index: 6328
Line: one more than three times the number of curves to be drawn because each Bezier curve requires wasn't a variable thing
Line: two control points and an endpoint, and the initial curve requires an additional starting point. wasn't a variable thing
Line: aPoints (variable): An array of PointS objects ([MS-WMF] section 2.2.2.16), which specify the WAS a variable thing
Line: points of the Bezier curves in logical units. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYBEZIER16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYBEZIER16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIER16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYBEZIERTO record specifies one or more Bezier curves based upon the current drawing wasn't a variable thing
Line: position. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: 144 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6358
Line: value is 0x00000005. wasn't a variable thing
Here is a field: Size
Line index: 6360
Here is a field: Bounds
Line index: 6361
Line: rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6363
Line: first curve MUST be drawn from the current position to the third point by using the first two points wasn't a variable thing
Line: as control points. For each subsequent curve, exactly three more points MUST be specified, and wasn't a variable thing
Line: the ending point of the previous curve MUST be used as the starting point for the next. wasn't a variable thing
Line: Line width Device supports wideline Maximum points allowed wasn't a variable thing
Line: 1 n/a 16K wasn't a variable thing
Line: > 1 yes 16K wasn't a variable thing
Line: > 1 no 1360 wasn't a variable thing
Line: Any extra points MUST be ignored. wasn't a variable thing
Line: aPoints (variable): An array of PointL objects ([MS-WMF] section 2.2.2.15), which specify the WAS a variable thing
Line: endpoints and control points of the Bezier curves in logical units. wasn't a variable thing
Line: The Bezier curves SHOULD be drawn using the current pen. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYBEZIERTO
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYBEZIERTO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIERTO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYBEZIERTO16 record specifies one or more Bezier curves based on the current drawing wasn't a variable thing
Line: position. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: 145 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6400
Line: This value is 0x00000058. wasn't a variable thing
Here is a field: Size
Line index: 6402
Here is a field: Bounds
Line index: 6403
Line: rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6405
Line: drawn from the current position to the third point by using the first two points as control points. wasn't a variable thing
Line: For each subsequent curve, three more points MUST be specified, and the ending point of the wasn't a variable thing
Line: previous curve MUST be used as the starting point for the next. wasn't a variable thing
Line: aPoints (variable): An array of PointS objects ([MS-WMF] section 2.2.2.16), which specify the WAS a variable thing
Line: points of the Bezier curves in logical units. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYBEZIERTO16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYBEZIERTO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIERTO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYDRAW record specifies a set of line segments and Bezier curves. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: abTypes (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6432
Line: is 0x00000038. wasn't a variable thing
Line: 146 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: Size
Line index: 6439
Here is a field: Bounds
Line index: 6440
Line: bounding rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6442
Line: aPoints (variable): An array of PointL objects ([MS-WMF] section 2.2.2.15), which specify the points WAS a variable thing
Line: in logical units. wasn't a variable thing
Line: abTypes (variable): A Count length array of byte values that specifies how each point in the WAS a variable thing
Line: aPoints array is used. This value is in the Point (section 2.1.26) enumeration. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYDRAW
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYDRAW
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYDRAW
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYDRAW16 record specifies a set of line segments and Bezier curves. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: abTypes (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6468
Line: value is 0x0000005C. wasn't a variable thing
Here is a field: Size
Line index: 6470
Here is a field: Bounds
Line index: 6471
Line: bounding rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6473
Line: 147 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: aPoints (variable): A Count length array of PointS objects, specified in [MS-WMF] section 2.2.2.16, WAS a variable thing
Line: which specifies the array of points. wasn't a variable thing
Line: abTypes (variable): A Count length array of bytes that specifies the point types. This value is in the WAS a variable thing
Line: Point (section 2.1.26) enumeration. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYDRAW16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYDRAW16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYDRAW16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYGON record specifies a polygon consisting of two or more vertexes connected by wasn't a variable thing
Line: straight lines. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6503
Line: 0x00000003. wasn't a variable thing
Here is a field: Size
Line index: 6505
Here is a field: Bounds
Line index: 6506
Line: rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6508
Line: Line width Device supports wideline Maximum points allowed wasn't a variable thing
Line: 1 n/a 16K wasn't a variable thing
Line: > 1 yes 16K wasn't a variable thing
Line: > 1 no 1360 wasn't a variable thing
Line: Any extra points MUST be ignored. wasn't a variable thing
Line: aPoints (variable): A Count length array of PointL objects ([MS-WMF] section 2.2.2.15) that WAS a variable thing
Line: specifies the vertexes of the polygon in logical units. wasn't a variable thing
Line: 148 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: The polygon SHOULD be outlined using the current pen and filled using the current brush and polygon wasn't a variable thing
Line: fill mode. The polygon SHOULD be closed automatically by drawing a line from the last vertex to the wasn't a variable thing
Line: first. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYGON
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYGON
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYGON
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYGON16 record specifies a polygon consisting of two or more vertexes connected by wasn't a variable thing
Line: straight lines. The polygon is outlined by using the current pen and filled by using the current brush wasn't a variable thing
Line: and polygon fill mode. The polygon is closed automatically by drawing a line from the last vertex to wasn't a variable thing
Line: the first. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6546
Line: value is 0x00000056. wasn't a variable thing
Here is a field: Size
Line index: 6548
Here is a field: Bounds
Line index: 6549
Line: bounding rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6551
Line: aPoints (variable): A Count length array of PointS objects, specified in [MS-WMF] section 2.2.2.16, WAS a variable thing
Line: which specifies the array of points. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYGON16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYLINE record specifies a series of line segments by connecting the points in the specified wasn't a variable thing
Line: array. wasn't a variable thing
Line: 149 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6579
Line: is 0x00000004. wasn't a variable thing
Here is a field: Size
Line index: 6581
Here is a field: Bounds
Line index: 6582
Line: rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6584
Line: Line width Device supports wideline Maximum points allowed wasn't a variable thing
Line: 1 n/a 16K wasn't a variable thing
Line: > 1 yes 16K wasn't a variable thing
Line: > 1 no 1360 wasn't a variable thing
Line: Any extra points MUST be ignored. wasn't a variable thing
Line: aPoints (variable): A Count length array of PointL objects ([MS-WMF] section 2.2.2.15) that WAS a variable thing
Line: specifies the point data, in logical units. wasn't a variable thing
Line: The line segments SHOULD be drawn using the current pen. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYLINE
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYLINE16 record specifies a series of line segments by connecting the points in the wasn't a variable thing
Line: specified array. wasn't a variable thing
Line: 150 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6618
Line: value is 0x00000057. wasn't a variable thing
Here is a field: Size
Line index: 6620
Here is a field: Bounds
Line index: 6621
Line: bounding rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6623
Line: aPoints (variable): A Count length array of PointS objects, specified in [MS-WMF] section 2.2.2.16, WAS a variable thing
Line: which specifies the array of points. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYLINE16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYLINETO record specifies one or more straight lines based upon the current drawing wasn't a variable thing
Line: position. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: 151 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6651
Line: value is 0x00000006. wasn't a variable thing
Here is a field: Size
Line index: 6653
Here is a field: Bounds
Line index: 6654
Line: bounding rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6656
Line: Line width Device supports wideline Maximum points allowed wasn't a variable thing
Line: 1 n/a 16K wasn't a variable thing
Line: > 1 yes 16K wasn't a variable thing
Line: > 1 no 1360 wasn't a variable thing
Line: Any extra points MUST be ignored. wasn't a variable thing
Line: aPoints (variable): A Count length array of PointL objects ([MS-WMF] section 2.2.2.15, which WAS a variable thing
Line: specifies the point data, in logical units. wasn't a variable thing
Line: A line SHOULD be drawn from the current position to the first point specified by the aPoints field wasn't a variable thing
Line: using the current pen. Each additional line SHOULD be drawn from the ending point of the previous wasn't a variable thing
Line: line to the next point specified by aPoints. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYLINETO
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYLINETO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINETO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYLINETO16 record specifies one or more straight lines based upon the current drawing wasn't a variable thing
Line: position. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: 152 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6692
Line: value is 0x00000059. wasn't a variable thing
Here is a field: Size
Line index: 6694
Here is a field: Bounds
Line index: 6695
Line: rectangle in logical units. wasn't a variable thing
Here is a field: Count
Line index: 6697
Line: aPoints (variable): A Count length array of PointS objects ([MS-WMF] section 2.2.2.16, which WAS a variable thing
Line: specifies the array of points. wasn't a variable thing
Line: A line is drawn from the current drawing position to the first point specified by the aPoints field by wasn't a variable thing
Line: using the current pen. For each additional line, drawing is performed from the ending point of the wasn't a variable thing
Line: previous line to the next point specified by aPoints. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYLINETO16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'Count']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_POLYLINETO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINETO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Line: The EMR_POLYPOLYGON record specifies a series of closed polygons. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.5. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: NumberOfPolygons wasn't a variable thing
Line: Count wasn't a variable thing
Line: PolygonPointCount (variable) WAS a variable thing
Line: 153 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6731
Line: value is 0x00000008. wasn't a variable thing
Here is a field: Bounds
Line index: 6733
Line: rectangle in logical units. wasn't a variable thing
Here is a field: NumberOfPolygons
Line index: 6735
Here is a field: Count
Line index: 6736
Line: Line width Device supports wideline Maximum points allowed wasn't a variable thing
Line: 1 n/a 16K wasn't a variable thing
Line: > 1 yes 16K wasn't a variable thing
Line: > 1 no 1360 wasn't a variable thing
Line: Any extra points MUST be ignored. To draw a line with more points, the data SHOULD be divided wasn't a variable thing
Line: into groups that have less than the maximum number of points, and an EMR_POLYPOLYGON wasn't a variable thing
Line: operation SHOULD be performed for each group of points. wasn't a variable thing
Line: PolygonPointCount (variable): An array of 32-bit unsigned integers that specifies the point count WAS a variable thing
Line: for each polygon. wasn't a variable thing
Line: aPoints (variable): An array of PointL objects ([MS-WMF] section 2.2.2.15) that specifies the points WAS a variable thing
Line: for all polygons in logical units. The number of points is specified by the Count field value. wasn't a variable thing
Line: Each polygon SHOULD be outlined using the current pen, and filled using the current brush and wasn't a variable thing
Line: polygon fill mode that are defined in the playback device context. The polygons defined by this wasn't a variable thing
Line: record can overlap. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYPOLYGON
has_variable: True
fields: ['Type', 'Bounds', 'NumberOfPolygons', 'Count']
struct_format: ['4b', '16b', '4b', '4b']
Bullshit before...
Name: EMR_POLYPOLYGON
Here is the struct format: ['4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'NumberOfPolygons', 'Count']
Fields before: ['Type', 'Bounds', 'NumberOfPolygons', 'Count']
Fields after: ['Bounds', 'NumberOfPolygons', 'Count']
Bullshit after...
Name: EMR_POLYPOLYGON
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Line: The EMR_POLYPOLYGON16 record specifies a series of closed polygons. Each polygon is outlined using wasn't a variable thing
Line: the current pen, and filled using the current brush and polygon fill mode. The polygons drawn by this wasn't a variable thing
Line: record can overlap. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: 154 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: NumberOfPolygons wasn't a variable thing
Line: Count wasn't a variable thing
Line: PolygonPointCount (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6780
Line: This value is 0x0000005B. wasn't a variable thing
Here is a field: Size
Line index: 6782
Here is a field: Bounds
Line index: 6783
Line: rectangle in logical units. wasn't a variable thing
Here is a field: NumberOfPolygons
Line index: 6785
Here is a field: Count
Line index: 6786
Line: PolygonPointCount (variable): A NumberOfPolygons length array of 32-bit unsigned integers WAS a variable thing
Line: that specifies the point counts for each polygon. wasn't a variable thing
Line: aPoints (variable): A Count length array of PointS objects ([MS-WMF] section 2.2.2.16), which WAS a variable thing
Line: specifies the array of points. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYPOLYGON16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
struct_format: ['4b', '4b', '16b', '4b', '4b']
Bullshit before...
Name: EMR_POLYPOLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Fields after: ['Bounds', 'NumberOfPolygons', 'Count']
Bullshit after...
Name: EMR_POLYPOLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Line: The EMR_POLYPOLYLINE record draws multiple series of connected line segments. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: 155 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: NumberOfPolylines wasn't a variable thing
Line: Count wasn't a variable thing
Line: aPolylinePointCount (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6818
Line: value is 0x00000007. wasn't a variable thing
Here is a field: Size
Line index: 6820
Here is a field: Bounds
Line index: 6821
Line: rectangle in logical units. wasn't a variable thing
Here is a field: NumberOfPolylines
Line index: 6823
Line: the number of elements in the aPolylinePointCount array. wasn't a variable thing
Here is a field: Count
Line index: 6825
Line: is the number of elements in the aPoints array. wasn't a variable thing
Line: Line width Device supports wideline Maximum points allowed wasn't a variable thing
Line: 1 n/a 16K wasn't a variable thing
Line: > 1 yes 16K wasn't a variable thing
Line: > 1 no 1360 wasn't a variable thing
Line: Any extra points MUST be ignored. wasn't a variable thing
Line: aPolylinePointCount (variable): A NumberOfPolylines-length array of 32-bit unsigned integers WAS a variable thing
Line: that specify the point counts for all polylines. Each value MUST be >= 0x00000002. wasn't a variable thing
Line: Each point count refers to a number of consecutive elements in the aPoints array. wasn't a variable thing
Line: aPoints (variable): A Count-length array of PointL objects ([MS-WMF] section 2.2.2.15) that specify WAS a variable thing
Line: the point data, in logical units. wasn't a variable thing
Line: The line segments SHOULD be drawn using the current pen. The figures formed by the segments wasn't a variable thing
Line: SHOULD NOT filled. The current drawing position SHOULD neither be used nor updated by this record. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYPOLYLINE
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
struct_format: ['4b', '4b', '16b', '4b', '4b']
Bullshit before...
Name: EMR_POLYPOLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields after: ['Bounds', 'NumberOfPolylines', 'Count']
Bullshit after...
Name: EMR_POLYPOLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Line: The EMR_POLYPOLYLINE16 record specifies multiple series of connected line segments. wasn't a variable thing
Line: 156 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: NumberOfPolylines wasn't a variable thing
Line: Count wasn't a variable thing
Line: PolylinePointCount (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: aPoints (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6866
Line: This value is 0x0000005A. wasn't a variable thing
Here is a field: Size
Line index: 6868
Here is a field: Bounds
Line index: 6869
Line: rectangle in logical units. wasn't a variable thing
Here is a field: NumberOfPolylines
Line index: 6871
Here is a field: Count
Line index: 6872
Line: PolylinePointCount (variable): A NumberOfPolylines length array of 32-bit unsigned integers WAS a variable thing
Line: that specifies the point counts for each polyline. wasn't a variable thing
Line: aPoints (variable): A Count length array of PointS objects ([MS-WMF] section 2.2.2.16), which WAS a variable thing
Line: specifies the array of points. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYPOLYLINE16
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
struct_format: ['4b', '4b', '16b', '4b', '4b']
Bullshit before...
Name: EMR_POLYPOLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields after: ['Bounds', 'NumberOfPolylines', 'Count']
Bullshit after...
Name: EMR_POLYPOLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Line: The EMR_POLYTEXTOUTA record draws one or more ASCII text strings using the current font and text wasn't a variable thing
Line: colors. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.5. wasn't a variable thing
Line: 157 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: iGraphicsMode wasn't a variable thing
Line: exScale wasn't a variable thing
Line: eyScale wasn't a variable thing
Line: cStrings wasn't a variable thing
Line: aEmrText (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6906
Line: value is 0x00000060. wasn't a variable thing
Here is a field: Bounds
Line index: 6908
Line: rectangle in logical units. wasn't a variable thing
Here is a field: iGraphicsMode
Line index: 6910
Line: GraphicsMode enumeration (section 2.1.16). wasn't a variable thing
Here is a field: exScale
Line index: 6912
Line: graphics mode is GM_COMPATIBLE. wasn't a variable thing
Here is a field: eyScale
Line index: 6914
Line: graphics mode is GM_COMPATIBLE. wasn't a variable thing
Here is a field: cStrings
Line index: 6916
Line: aEmrText (variable): An array of EmrText objects (section 2.2.5) that specify the output strings in WAS a variable thing
Line: 8-bit ASCII characters, with text attributes, and spacing values. The number of EmrText objects is wasn't a variable thing
Line: specified by cStrings. wasn't a variable thing
Line: The font and text colors used for output are specified by properties in the current state of EMF wasn't a variable thing
Line: metafile playback (section 3.1). wasn't a variable thing
Line: EMR_POLYTEXTOUTA SHOULD<70> be emulated with a series of EMR_EXTTEXTOUTW records wasn't a variable thing
Line: (section 2.3.5.7), one per string. This requires the ASCII text string in each EmrText object to be wasn't a variable thing
Line: converted to Unicode UTF16-LE encoding. wasn't a variable thing
Line: 158 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYTEXTOUTA
has_variable: True
fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_POLYTEXTOUTA
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Bullshit after...
Name: EMR_POLYTEXTOUTA
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Line: The EMR_POLYTEXTOUTW record draws one or more Unicode text strings using the current font and wasn't a variable thing
Line: text colors. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.5. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: iGraphicsMode wasn't a variable thing
Line: exScale wasn't a variable thing
Line: eyScale wasn't a variable thing
Line: cStrings wasn't a variable thing
Line: wEmrText (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6954
Line: value is 0x00000061. wasn't a variable thing
Here is a field: Bounds
Line index: 6956
Line: rectangle in logical units. wasn't a variable thing
Here is a field: iGraphicsMode
Line index: 6958
Line: modes are specified in section 2.1.16. wasn't a variable thing
Here is a field: exScale
Line index: 6960
Line: graphics mode is GM_COMPATIBLE. wasn't a variable thing
Here is a field: eyScale
Line index: 6962
Line: graphics mode is GM_COMPATIBLE. wasn't a variable thing
Here is a field: cStrings
Line index: 6964
Line: 159 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: wEmrText (variable): An array of EmrText objects (section 2.2.5) that specify the output strings in WAS a variable thing
Line: Unicode UTF16-LE characters, with text attributes and spacing values. The number of EmrText wasn't a variable thing
Line: objects is specified by cStrings. wasn't a variable thing
Line: The font and text colors used for output are specified by properties in the current state of the wasn't a variable thing
Line: playback device context. wasn't a variable thing
Line: EMR_POLYTEXTOUTW SHOULD be emulated with a series of EMR_EXTTEXTOUTW records (section wasn't a variable thing
Line: 2.3.5.7), one per string.<71> wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_POLYTEXTOUTW
has_variable: True
fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
struct_format: ['4b', '16b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_POLYTEXTOUTW
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Bullshit after...
Name: EMR_POLYTEXTOUTW
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Line: The EMR_RECTANGLE record draws a rectangle. The rectangle is outlined by using the current pen and wasn't a variable thing
Line: filled by using the current brush. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Box wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 6994
Line: value is 0x0000002B. wasn't a variable thing
Here is a field: Size
Line index: 6996
Here is a field: Box
Line index: 6997
Line: The current drawing position is neither used nor updated by this record. wasn't a variable thing
Line: If a PS_NULL pen is used, the dimensions of the rectangle are 1 pixel less in height and 1 pixel less wasn't a variable thing
Line: in width. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_RECTANGLE
has_variable: False
fields: ['Type', 'Size', 'Box']
struct_format: ['4b', '4b', '16b']
Bullshit before...
Name: EMR_RECTANGLE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Fields before: ['Type', 'Size', 'Box']
Fields after: ['Box']
Bullshit after...
Name: EMR_RECTANGLE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Line: The EMR_ROUNDRECT record specifies a rectangle with rounded corners. The rectangle is outlined by wasn't a variable thing
Line: using the current pen and filled by using the current brush. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: 160 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Size wasn't a variable thing
Line: Box wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: Corner wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7025
Line: value is 0x0000002C. wasn't a variable thing
Here is a field: Size
Line index: 7027
Here is a field: Box
Line index: 7028
Here is a field: Corner
Line index: 7029
Line: height, in logical coordinates, of the ellipse used to draw the rounded corners. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_ROUNDRECT
has_variable: False
fields: ['Type', 'Size', 'Box', 'Corner']
struct_format: ['4b', '4b', '16b', '8b']
Bullshit before...
Name: EMR_ROUNDRECT
Here is the struct format: ['4b', '4b', '16b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Corner']
Fields before: ['Type', 'Size', 'Box', 'Corner']
Fields after: ['Box', 'Corner']
Bullshit after...
Name: EMR_ROUNDRECT
Here is the struct format: ['4b', '4b', '16b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Corner']
Line: The EMR_SETPIXELV record defines the color of the pixel at the specified logical coordinates. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Pixel wasn't a variable thing
Line: ... wasn't a variable thing
Line: Color wasn't a variable thing
Here is a field: Type
Line index: 7046
Line: is 0x0000000F. wasn't a variable thing
Here is a field: Size
Line index: 7048
Here is a field: Pixel
Line index: 7049
Line: for the pixel. wasn't a variable thing
Here is a field: Color
Line index: 7051
Line: 161 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_SETPIXELV
has_variable: False
fields: ['Type', 'Size', 'Pixel', 'Color']
struct_format: ['4b', '4b', '8b', '4b']
Bullshit before...
Name: EMR_SETPIXELV
Here is the struct format: ['4b', '4b', '8b', '4b']
Here is the fields: ['Type', 'Size', 'Pixel', 'Color']
Fields before: ['Type', 'Size', 'Pixel', 'Color']
Fields after: ['Pixel', 'Color']
Bullshit after...
Name: EMR_SETPIXELV
Here is the struct format: ['4b', '4b', '8b', '4b']
Here is the fields: ['Type', 'Size', 'Pixel', 'Color']
Line: The EMR_SMALLTEXTOUT record outputs a string. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: x wasn't a variable thing
Line: y wasn't a variable thing
Line: cChars wasn't a variable thing
Line: fuOptions wasn't a variable thing
Line: iGraphicsMode wasn't a variable thing
Line: exScale wasn't a variable thing
Line: eyScale wasn't a variable thing
Line: Bounds (optional) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: TextString (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7082
Line: value is 0x0000006C. wasn't a variable thing
Here is a field: Size
Line index: 7084
Here is a field: x
Line index: 7085
Here is a field: y
Line index: 7086
Here is a field: cChars
Line index: 7087
Line: string is NOT null-terminated. wasn't a variable thing
Line: 162 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: fuOptions
Line index: 7094
Line: are specified by one or a combination of values from the ExtTextOutOptions enumeration (section wasn't a variable thing
Line: 2.1.11). wasn't a variable thing
Here is a field: iGraphicsMode
Line index: 7097
Line: GraphicsMode enumeration (section 2.1.16). wasn't a variable thing
Here is a field: exScale
Line index: 7099
Here is a field: eyScale
Line index: 7100
Line: Bounds (16 bytes, optional): A RectL object ([MS-WMF] section 2.2.2.19) that specifies the wasn't a variable thing
Line: bounding rectangle in logical units. wasn't a variable thing
Line: TextString (variable): A string that contains the text string to draw, in either 8-bit or 16-bit WAS a variable thing
Line: character codes, according to the value of the fuOptions field. wasn't a variable thing
Line: If ETO_SMALL_CHARS is set in the fuOptions field, TextString contains 8-bit codes for characters, wasn't a variable thing
Line: derived from the low bytes of Unicode UTF16-LE character codes, in which the high byte is assumed wasn't a variable thing
Line: to be 0. wasn't a variable thing
Line: If ETO_NO_RECT is set in the fuOptions field, the Bounds field is not included in the record. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_SMALLTEXTOUT
has_variable: True
fields: ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SMALLTEXTOUT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Fields before: ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Fields after: ['x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Bullshit after...
Name: EMR_SMALLTEXTOUT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Line: The EMR_STROKEANDFILLPATH record closes any open figures in a path, strokes the outline of the wasn't a variable thing
Line: path by using the current pen, and fills its interior by using the current brush. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7126
Line: EMR_STROKEANDFILLPATH. This value is 0x0000003F. wasn't a variable thing
Here is a field: Size
Line index: 7128
Here is a field: Bounds
Line index: 7129
Line: rectangle in logical units. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Line: 163 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_STROKEANDFILLPATH
has_variable: False
fields: ['Type', 'Size', 'Bounds']
struct_format: ['4b', '4b', '16b']
Bullshit before...
Name: EMR_STROKEANDFILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Fields before: ['Type', 'Size', 'Bounds']
Fields after: ['Bounds']
Bullshit after...
Name: EMR_STROKEANDFILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Line: The EMR_STROKEPATH record renders the specified path by using the current pen. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7152
Line: value is 0x00000040. wasn't a variable thing
Here is a field: Size
Line index: 7154
Here is a field: Bounds
Line index: 7155
Line: rectangle in logical units. wasn't a variable thing
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Line: 2.3.6 Escape Record Types wasn't a variable thing
Line: The Escape record types execute printer driver functions. wasn't a variable thing
Line: The following are EMF escape record types. wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_DRAWESCAPE 2.3.6.1 Passes arbitrary information to the printer driver. The intent is that the wasn't a variable thing
Line: information results in drawing being done. wasn't a variable thing
Line: EMR_EXTESCAPE 2.3.6.2 Passes arbitrary information to the printer driver. The intent is that the wasn't a variable thing
Line: information does not result in drawing being done. wasn't a variable thing
Line: EMR_NAMEDESCAPE 2.3.6.3 Passes arbitrary information to the given named printer driver. wasn't a variable thing
Line: The generic structure of escape records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: iEscape wasn't a variable thing
Line: 164 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: EscapeRecordBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Name: EMR_STROKEPATH
has_variable: True
fields: ['Type', 'Size', 'Bounds']
struct_format: ['4b', '4b', '16b']
Bullshit before...
Name: EMR_STROKEPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Fields before: ['Type', 'Size', 'Bounds']
Fields after: ['Bounds']
Bullshit after...
Name: EMR_STROKEPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Line: The EMR_DRAWESCAPE record passes arbitrary information to a printer driver. The intent is that the wasn't a variable thing
Line: information results in drawing being done. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.6. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: 165 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Size wasn't a variable thing
Line: iEscape wasn't a variable thing
Line: cjIn wasn't a variable thing
Line: Data (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7235
Line: enumeration (section 2.1.1). It MUST be EMR_DRAWESCAPE, which is 0x00000069. wasn't a variable thing
Here is a field: cjIn
Line index: 7237
Line: Data (variable): The data to pass to the printer driver. There MUST be cjIn bytes available. WAS a variable thing
Line: See section 2.3.6 for more escape record types. wasn't a variable thing
Name: EMR_DRAWESCAPE
has_variable: True
fields: ['Type', 'cjIn']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_DRAWESCAPE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'cjIn']
Fields before: ['Type', 'cjIn']
Fields after: ['cjIn']
Bullshit after...
Name: EMR_DRAWESCAPE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cjIn']
Line: The EMR_EXTESCAPE record passes arbitrary information to a printer driver. The intent is that the wasn't a variable thing
Line: information does not result in drawing being done. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.6. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: iEscape wasn't a variable thing
Line: cjIn wasn't a variable thing
Line: Data (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7257
Line: enumeration (section 2.1.1). This value is 0x0000006A. wasn't a variable thing
Here is a field: cjIn
Line index: 7259
Line: Data (variable): The data to pass to the printer driver. There MUST be cjIn bytes available. WAS a variable thing
Line: See section 2.3.6 for more escape record types. wasn't a variable thing
Name: EMR_EXTESCAPE
has_variable: True
fields: ['Type', 'cjIn']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_EXTESCAPE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'cjIn']
Fields before: ['Type', 'cjIn']
Fields after: ['cjIn']
Bullshit after...
Name: EMR_EXTESCAPE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cjIn']
Line: The EMR_NAMEDESCAPE record passes arbitrary information to a named printer driver. wasn't a variable thing
Line: 166 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.6. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: iEscape wasn't a variable thing
Line: cjDriver wasn't a variable thing
Line: cjIn wasn't a variable thing
Line: DriverName (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: Data (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7286
Line: enumeration (section 2.1.1). It MUST be EMR_NAMEDESCAPE, which is 0x0000006E. wasn't a variable thing
Here is a field: cjDriver
Line index: 7288
Line: This value MUST be an even number. wasn't a variable thing
Here is a field: cjIn
Line index: 7290
Line: printer driver. wasn't a variable thing
Line: DriverName (variable): A null-terminated string of Unicode characters that specifies the name of WAS a variable thing
Line: the printer driver to receive data. wasn't a variable thing
Line: Data (variable): The data to pass to the printer driver. WAS a variable thing
Line: See section 2.3.6 for more escape record types. wasn't a variable thing
Line: 2.3.7 Object Creation Record Types wasn't a variable thing
Line: The Object Creation record types create graphics objects. wasn't a variable thing
Line: The following are EMF object creation record types. wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_CREATEBRUSHINDIRECT 2.3.7.1 Defines a logical brush with a LogBrushEx object (section wasn't a variable thing
Line: 2.2.12). wasn't a variable thing
Line: EMR_CREATECOLORSPACE 2.3.7.2 Defines a logical color space with a LogColorSpace object wasn't a variable thing
Line: ([MS-WMF] section 2.2.2.11). wasn't a variable thing
Line: EMR_CREATECOLORSPACEW 2.3.7.3 Defines a logical color space with a LogColorSpaceW object wasn't a variable thing
Line: ([MS-WMF] section 2.2.2.12). wasn't a variable thing
Line: 167 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_CREATEDIBPATTERNBRUSHPT 2.3.7.4 Defines a pattern brush with a DeviceIndependentBitmap object wasn't a variable thing
Line: ([MS-WMF] section 2.2.2.9). wasn't a variable thing
Line: EMR_CREATEMONOBRUSH 2.3.7.5 Defines a monochrome pattern brush with a monochrome wasn't a variable thing
Line: DeviceIndependentBitmap object. wasn't a variable thing
Line: EMR_CREATEPALETTE 2.3.7.6 Defines a logical palette with a LogPalette object (section wasn't a variable thing
Line: 2.2.17). wasn't a variable thing
Line: EMR_CREATEPEN 2.3.7.7 Defines a logical pen with a LogPen object (section 2.2.19). wasn't a variable thing
Line: EMR_EXTCREATEFONTINDIRECTW 2.3.7.8 Defines a logical font with either a LogFont object (section wasn't a variable thing
Line: 2.2.13) or LogFontExDv object (section 2.2.15). wasn't a variable thing
Line: EMR_EXTCREATEPEN 2.3.7.9 Defines a logical pen with a LogPenEx object (section 2.2.20) wasn't a variable thing
Line: and optional DeviceIndependentBitmap object. wasn't a variable thing
Line: The generic structure of object creation records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ObjectRecordBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Name: EMR_NAMEDESCAPE
has_variable: True
fields: ['Type', 'cjDriver', 'cjIn']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_NAMEDESCAPE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'cjDriver', 'cjIn']
Fields before: ['Type', 'cjDriver', 'cjIn']
Fields after: ['cjDriver', 'cjIn']
Bullshit after...
Name: EMR_NAMEDESCAPE
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cjDriver', 'cjIn']
Line: The EMR_CREATEBRUSHINDIRECT record defines a logical brush for graphics operations. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihBrush wasn't a variable thing
Line: LogBrush wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7387
Line: EMR_CREATEBRUSHINDIRECT. This value is 0x00000027. wasn't a variable thing
Here is a field: Size
Line index: 7389
Line: 0x00000018. wasn't a variable thing
Here is a field: ihBrush
Line index: 7391
Line: object table (section 3.1.1.1). This index is used to refer to the object, so it can be reused or wasn't a variable thing
Line: modified. wasn't a variable thing
Here is a field: LogBrush
Line index: 7394
Line: pattern of the logical brush. The BrushStyle field in this object MUST be BS_SOLID, wasn't a variable thing
Line: BS_HATCHED, or BS_NULL. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Line: 169 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_CREATEBRUSHINDIRECT
has_variable: False
fields: ['Type', 'Size', 'ihBrush', 'LogBrush']
struct_format: ['4b', '4b', '4b', '12b']
Bullshit before...
Name: EMR_CREATEBRUSHINDIRECT
Here is the struct format: ['4b', '4b', '4b', '12b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'LogBrush']
Fields before: ['Type', 'Size', 'ihBrush', 'LogBrush']
Fields after: ['ihBrush', 'LogBrush']
Bullshit after...
Name: EMR_CREATEBRUSHINDIRECT
Here is the struct format: ['4b', '4b', '4b', '12b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'LogBrush']
Line: The EMR_CREATECOLORSPACE record creates a logical color space object from a color profile wasn't a variable thing
Line: with a name consisting of ASCII characters.<72> wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.7. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihCS wasn't a variable thing
Line: lcs (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7419
Line: This value is 0x00000063. wasn't a variable thing
Here is a field: ihCS
Line index: 7421
Line: EMF object table (section 3.1.1.1). This index MUST be saved so that this object can be reused wasn't a variable thing
Line: or modified. wasn't a variable thing
Line: lcs (variable): A LogColorSpace object ([MS-WMF] section 2.2.2.11), which can specify the name of WAS a variable thing
Line: a color profile in ASCII characters. wasn't a variable thing
Line: The logical color space object defined by this record can be selected into the playback device wasn't a variable thing
Line: context by an EMR_SETCOLORSPACE record (section 2.3.8.7), which defines the logical color space wasn't a variable thing
Line: to use in subsequent graphics operations. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Name: EMR_CREATECOLORSPACE
has_variable: True
fields: ['Type', 'ihCS']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_CREATECOLORSPACE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'ihCS']
Fields before: ['Type', 'ihCS']
Fields after: ['ihCS']
Bullshit after...
Name: EMR_CREATECOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Line: The EMR_CREATECOLORSPACEW record creates a logical color space object from a color profile wasn't a variable thing
Line: with a name consisting of Unicode characters.<73> wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.7. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihCS wasn't a variable thing
Line: lcs (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: 170 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: dwFlags wasn't a variable thing
Line: cbData wasn't a variable thing
Line: Data (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7455
Line: EMR_CREATECOLORSPACEW. This value is 0x0000007A. wasn't a variable thing
Here is a field: ihCS
Line index: 7457
Line: EMF object table (section 3.1.1.1). This index MUST be saved so that this object can be reused wasn't a variable thing
Line: or modified. wasn't a variable thing
Line: lcs (variable): A LogColorSpaceW object ([MS-WMF] section 2.2.2.12) that can specify the name of a WAS a variable thing
Line: color profile in Unicode UTF16-LE characters. wasn't a variable thing
Here is a field: dwFlags
Line index: 7462
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: 0 C wasn't a variable thing
Line: C (1 bit): If set, the Data field contains color profile data. wasn't a variable thing
Here is a field: cbData
Line index: 7472
Line: Data (variable, optional): An array of bytes that specifies color profile data. When cbData is zero, WAS a variable thing
Line: this field is optional and is ignored. wasn't a variable thing
Line: The logical color space object defined by this record can be selected into the playback device wasn't a variable thing
Line: context by an EMR_SETCOLORSPACE record (section 2.3.8.7), which defines the logical color spaceto wasn't a variable thing
Line: use in subsequent graphics operations. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Name: EMR_CREATECOLORSPACEW
has_variable: True
fields: ['Type', 'ihCS', 'dwFlags', 'cbData']
struct_format: ['4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_CREATECOLORSPACEW
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihCS', 'dwFlags', 'cbData']
Fields before: ['Type', 'ihCS', 'dwFlags', 'cbData']
Fields after: ['ihCS', 'dwFlags', 'cbData']
Bullshit after...
Name: EMR_CREATECOLORSPACEW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS', 'dwFlags', 'cbData']
Line: The EMR_CREATEDIBPATTERNBRUSHPT record defines a pattern brush for graphics operations. The wasn't a variable thing
Line: pattern is specified by a DIB. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.7. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihBrush wasn't a variable thing
Line: 171 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Usage wasn't a variable thing
Line: offBmi wasn't a variable thing
Line: cbBmi wasn't a variable thing
Line: offBits wasn't a variable thing
Line: cbBits wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7505
Line: EMR_CREATEDIBPATTERNBRUSHPT. This value is 0x0000005E. wasn't a variable thing
Here is a field: ihBrush
Line index: 7507
Line: EMF object table (section 3.1.1.1). This index MUST be saved so that this object can be reused wasn't a variable thing
Line: or modified. wasn't a variable thing
Here is a field: Usage
Line index: 7510
Line: DIB header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: offBmi
Line index: 7512
Line: DIB header. wasn't a variable thing
Here is a field: cbBmi
Line index: 7514
Here is a field: offBits
Line index: 7515
Line: DIB bits. wasn't a variable thing
Here is a field: cbBits
Line index: 7517
Line: BitmapBuffer (variable): A buffer containing a packed DIB in the form of a WAS a variable thing
Line: DeviceIndependentBitmap object ([MS-WMF] section 2.2.2.9). It is not required to be contiguous wasn't a variable thing
Line: with the fixed portion of this record. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace (variable, optional): An array of bytes that MUST be ignored. WAS a variable thing
Line: 172 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: BmiSrc (variable): The DIB header, which is the DibHeaderInfo field of a WAS a variable thing
Line: DeviceIndependentBitmap object. wasn't a variable thing
Line: BitsSrc (variable): The DIB bits, which is the aData field of a DeviceIndependentBitmap object. WAS a variable thing
Line: The pattern brush object defined by this record can be selected into the playback device context by wasn't a variable thing
Line: an EMR_SELECTOBJECT record (section 2.3.8.5), which specifies the pattern brush to use in wasn't a variable thing
Line: subsequent graphics operations. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Name: EMR_CREATEDIBPATTERNBRUSHPT
has_variable: True
fields: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_CREATEDIBPATTERNBRUSHPT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields before: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields after: ['ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Bullshit after...
Name: EMR_CREATEDIBPATTERNBRUSHPT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Line: The EMR_CREATEMONOBRUSH record defines a monochrome pattern brush for graphics operations. wasn't a variable thing
Line: The pattern is specified by a monochrome DIB. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.7. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihBrush wasn't a variable thing
Line: Usage wasn't a variable thing
Line: offBmi wasn't a variable thing
Line: cbBmi wasn't a variable thing
Line: offBits wasn't a variable thing
Line: cbBits wasn't a variable thing
Line: BitmapBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7568
Line: This value is 0x0000005D. wasn't a variable thing
Here is a field: ihBrush
Line index: 7570
Line: object in the EMF object table (section 3.1.1.1). This index MUST be saved so that this object can wasn't a variable thing
Line: be reused or modified. wasn't a variable thing
Here is a field: Usage
Line index: 7573
Line: DIB header. This value is in the DIBColors enumeration (section 2.1.9). wasn't a variable thing
Here is a field: offBmi
Line index: 7575
Line: DIB header. wasn't a variable thing
Here is a field: cbBmi
Line index: 7577
Line: 173 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: offBits
Line index: 7583
Line: DIB bits. wasn't a variable thing
Here is a field: cbBits
Line index: 7585
Line: BitmapBuffer (variable): A buffer containing a packed DIB in the form of a monochrome WAS a variable thing
Line: DeviceIndependentBitmap object ([MS-WMF] section 2.2.2.9). It is not required to be contiguous wasn't a variable thing
Line: with the fixed portion of this record. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace (variable, optional): An array of bytes that MUST be ignored. WAS a variable thing
Line: BmiSrc (variable): The DIB header, which is the DibHeaderInfo field of a WAS a variable thing
Line: DeviceIndependentBitmap object. wasn't a variable thing
Line: BitsSrc (variable): The DIB bits, which is the aData field of a DeviceIndependentBitmap object. WAS a variable thing
Line: The monochrome pattern brush object defined by this record can be selected into the playback wasn't a variable thing
Line: device context by an EMR_SELECTOBJECT record (section 2.3.8.5), which specifies the pattern brush wasn't a variable thing
Line: to use in subsequent graphics operations. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Name: EMR_CREATEMONOBRUSH
has_variable: True
fields: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_CREATEMONOBRUSH
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields before: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields after: ['ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Bullshit after...
Name: EMR_CREATEMONOBRUSH
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Line: The EMR_CREATEPALETTE record defines a logical palette for graphics operations. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.7. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihPal wasn't a variable thing
Line: LogPalette (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: 174 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: Type
Line index: 7630
Line: value is 0x00000031. wasn't a variable thing
Here is a field: ihPal
Line index: 7632
Line: object table (section 3.1.1.1). This index MUST be saved so that this object can be reused or wasn't a variable thing
Line: modified. wasn't a variable thing
Line: LogPalette (variable): A LogPalette object (section 2.2.17). The Version field of this object MUST WAS a variable thing
Line: be set to 0x0300. If the NumberOfEntries value in this object is zero, processing of this record wasn't a variable thing
Line: MUST fail. wasn't a variable thing
Line: The logical palette defined by this record can be selected into the playback device context by an wasn't a variable thing
Line: EMR_SELECTPALETTE record (section 2.3.8.6), which specifies the logical palette to use in subsequent wasn't a variable thing
Line: graphics operations. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Name: EMR_CREATEPALETTE
has_variable: True
fields: ['Type', 'ihPal']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_CREATEPALETTE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'ihPal']
Fields before: ['Type', 'ihPal']
Fields after: ['ihPal']
Bullshit after...
Name: EMR_CREATEPALETTE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal']
Line: The EMR_CREATEPEN record defines a logical pen for graphics operations. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihPen wasn't a variable thing
Line: LogPen wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7658
Line: is 0x00000026. wasn't a variable thing
Here is a field: Size
Line index: 7660
Line: 0x0000001C. wasn't a variable thing
Here is a field: ihPen
Line index: 7662
Line: object table (section 3.1.1.1). This index MUST be saved so that this object can be reused or wasn't a variable thing
Line: modified. wasn't a variable thing
Here is a field: LogPen
Line index: 7665
Line: logical pen. wasn't a variable thing
Line: The logical pen object defined by this record can be selected into the playback device context by an wasn't a variable thing
Line: EMR_SELECTOBJECT record (section 2.3.8.5), which specifies the logical pen to use in subsequent wasn't a variable thing
Line: graphics operations. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Line: 175 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_CREATEPEN
has_variable: False
fields: ['Type', 'Size', 'ihPen', 'LogPen']
struct_format: ['4b', '4b', '4b', '16b']
Bullshit before...
Name: EMR_CREATEPEN
Here is the struct format: ['4b', '4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'ihPen', 'LogPen']
Fields before: ['Type', 'Size', 'ihPen', 'LogPen']
Fields after: ['ihPen', 'LogPen']
Bullshit after...
Name: EMR_CREATEPEN
Here is the struct format: ['4b', '4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'ihPen', 'LogPen']
Line: The EMR_EXTCREATEFONTINDIRECTW record defines a logical font for graphics operations. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.7. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihFonts wasn't a variable thing
Line: elw (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7691
Line: EMR_EXTCREATEFONTINDIRECTW. This value is 0x00000052. wasn't a variable thing
Here is a field: ihFonts
Line index: 7693
Line: object table (section 3.1.1.1). This index MUST be saved so that this object can be reused or wasn't a variable thing
Line: modified. wasn't a variable thing
Line: elw (variable): A LogFontExDv object (section 2.2.15), which specifies the logical font. A LogFont WAS a variable thing
Line: object (section 2.2.13) MAY<74> be present instead. The process for determining the type of wasn't a variable thing
Line: object in this field is described below. wasn't a variable thing
Line: The logical font object defined by this record can be selected into the playback device context by an wasn't a variable thing
Line: EMR_SELECTOBJECT record (section 2.3.8.5), which specifies the logical font to use in subsequent wasn't a variable thing
Line: graphics operations. wasn't a variable thing
Line: The type of logical font object in the elw field of this record is determined by the following algorithm wasn't a variable thing
Line: (all size and length values are in bytes): wasn't a variable thing
Line:  First, note that the size in bytes of the static part of this record—that is, the sum of the sizes of its wasn't a variable thing
Line: Type, Size, and ihFonts fields—is 12. wasn't a variable thing
Line:  Next, note that because the size in bytes of the entire record is present in its Size field, the size in wasn't a variable thing
Line: bytes of the variable-length elw field can be computed as follows. wasn't a variable thing
Line: Size - 12 wasn't a variable thing
Line:  The size of the elw field must be equal to or greater than the size of a LogFontPanose wasn't a variable thing
Line: object.<75> wasn't a variable thing
Line:  If the size of the elw field is equal to the size of a LogFontPanose object (section 2.2.16), elw wasn't a variable thing
Line: MUST be treated as a fixed-length LogFontPanose object. wasn't a variable thing
Line:  If the size of the elw field is greater than the size of a LogFontPanose object, then elw MUST be wasn't a variable thing
Line: treated as a variable-length LogFontExDv object. wasn't a variable thing
Line: The size of a LogFontPanose object is 0x0140 (320 decimal). It is determined by adding up the sizes wasn't a variable thing
Line: of its fields, as follows: wasn't a variable thing
Line: 176 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line:  LogFont: The size of a LogFont object is 0x005C (92 decimal). It is determined by adding up the wasn't a variable thing
Line: sizes of its fields, as follows: wasn't a variable thing
Line:  Fields from Height through PitchAndFamily: 0x001C (28 decimal). wasn't a variable thing
Line:  Facename: The length is 32 16-bit characters: 0x0040 (64 decimal). wasn't a variable thing
Line:  Fullname: The length is 64 16-bit characters: 0x0080 (128 decimal). wasn't a variable thing
Line:  Style: The length is 32 16-bit characters: 0x0040 (64 decimal). wasn't a variable thing
Line:  Fields from Version through Culture: 0x0018 (24 decimal). wasn't a variable thing
Line:  Panose: The exact length of this field is 0x000A, but it MUST be padded by two additional bytes wasn't a variable thing
Line: for 32-bit alignment, so for the purposes of this computation the length is 0x000C (12 decimal). wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Name: EMR_EXTCREATEFONTINDIRECTW
has_variable: True
fields: ['Type', 'ihFonts']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_EXTCREATEFONTINDIRECTW
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'ihFonts']
Fields before: ['Type', 'ihFonts']
Fields after: ['ihFonts']
Bullshit after...
Name: EMR_EXTCREATEFONTINDIRECTW
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihFonts']
Line: The EMR_EXTCREATEPEN record defines an extended logical pen for graphics operations. An wasn't a variable thing
Line: optional DIB can be specified to use as the line style. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.7. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihPen wasn't a variable thing
Line: offBmi wasn't a variable thing
Line: cbBmi wasn't a variable thing
Line: offBits wasn't a variable thing
Line: cbBits wasn't a variable thing
Line: elp (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitmapBuffer (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 7754
Line: value is 0x0000005F. wasn't a variable thing
Line: 177 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: ihPen
Line index: 7761
Line: the EMF object table (section 3.1.1.1). This index MUST be saved so that this object can be wasn't a variable thing
Line: reused or modified. wasn't a variable thing
Here is a field: offBmi
Line index: 7764
Line: DIB header if the record contains a DIB. wasn't a variable thing
Here is a field: cbBmi
Line index: 7766
Line: a DIB. wasn't a variable thing
Here is a field: offBits
Line index: 7768
Line: DIB bits if the record contains a DIB. wasn't a variable thing
Here is a field: cbBits
Line index: 7770
Line: DIB. wasn't a variable thing
Line: elp (variable): A LogPenEx object (section 2.2.20) that specifies an extended logical pen with WAS a variable thing
Line: attributes including an optional line style array. wasn't a variable thing
Line: BitmapBuffer (variable, optional): An array of bytes containing a packed DIB in the form of a WAS a variable thing
Line: DeviceIndependentBitmap object ([MS-WMF] section 2.2.2.9). It is not required to be contiguous wasn't a variable thing
Line: with the fixed portion of this record. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: UndefinedSpace (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Line: BmiSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: BitsSrc (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: UndefinedSpace (variable, optional): An array of bytes that MUST be ignored. WAS a variable thing
Line: BmiSrc (variable): The DIB header, which is the DibHeaderInfo field of a WAS a variable thing
Line: DeviceIndependentBitmap object. wasn't a variable thing
Line: BitsSrc (variable): The DIB bits, which is the aData field of a DeviceIndependentBitmap object. WAS a variable thing
Line: The extended logical pen object defined by this record can be selected into the playback device wasn't a variable thing
Line: context by an EMR_SELECTOBJECT record (section 2.3.8.5), which specifies the logical pen to use in wasn't a variable thing
Line: subsequent graphics operations. wasn't a variable thing
Line: See section 2.3.7 for more object creation record types. wasn't a variable thing
Line: 2.3.8 Object Manipulation Record Types wasn't a variable thing
Line: The Object Manipulation record types manage and modify graphics objects. wasn't a variable thing
Line: The following are EMF object manipulation record types. wasn't a variable thing
Line: 178 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_COLORCORRECTPALETTE 2.3.8.1 Specifies how to correct the entries of a LogPalette wasn't a variable thing
Line: object (section 2.2.17) by using WCS values. wasn't a variable thing
Line: EMR_DELETECOLORSPACE 2.3.8.2 Specifies how to delete a logical color space from the EMF object wasn't a variable thing
Line: table (section 3.1.1.1). wasn't a variable thing
Line: EMR_DELETEOBJECT 2.3.8.3 Specifies the index of the object to be deleted from the EMF object wasn't a variable thing
Line: table. wasn't a variable thing
Line: EMR_RESIZEPALETTE 2.3.8.4 Increases or decreases the size of an existing LogPalette object. wasn't a variable thing
Line: EMR_SELECTOBJECT 2.3.8.5 Specifies an existing object based on its index in the EMF object table wasn't a variable thing
Line: and selects it into the playback device context wasn't a variable thing
Line: EMR_SELECTPALETTE 2.3.8.6 Selects the specified LogPalette object into the playback device wasn't a variable thing
Line: context. wasn't a variable thing
Line: EMR_SETCOLORSPACE 2.3.8.7 Specifies a logical color space, based on its index in the EMF object wasn't a variable thing
Line: table. wasn't a variable thing
Line: EMR_SETPALETTEENTRIES 2.3.8.8 Defines RGB color values in a range of entries for an existing wasn't a variable thing
Line: LogPalette object. wasn't a variable thing
Line: The generic structure of object manipulation records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ObjectRecordBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Name: EMR_EXTCREATEPEN
has_variable: True
fields: ['Type', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_EXTCREATEPEN
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields before: ['Type', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields after: ['ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Bullshit after...
Name: EMR_EXTCREATEPEN
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Line: The EMR_COLORCORRECTPALETTE record specifies the correction of entries of a logical palette wasn't a variable thing
Line: object using WCS.<76> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihPalette wasn't a variable thing
Line: nFirstEntry wasn't a variable thing
Line: nPalEntries wasn't a variable thing
Line: nReserved wasn't a variable thing
Here is a field: Type
Line index: 7887
Line: EMR_COLORCORRECTPALETTE. This value is 0x0000006F. wasn't a variable thing
Here is a field: Size
Line index: 7889
Line: 0x00000018. wasn't a variable thing
Here is a field: ihPalette
Line index: 7891
Line: 2.2.17) in the EMF object table (section 3.1.1.1). wasn't a variable thing
Here is a field: nFirstEntry
Line index: 7893
Line: 180 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: nPalEntries
Line index: 7899
Here is a field: nReserved
Line index: 7900
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Name: EMR_COLORCORRECTPALETTE
has_variable: False
fields: ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_COLORCORRECTPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Fields before: ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Fields after: ['ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Bullshit after...
Name: EMR_COLORCORRECTPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Line: The EMR_DELETECOLORSPACE record deletes a logical color space object.<77> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihCS wasn't a variable thing
Here is a field: Type
Line index: 7914
Line: This value is 0x00000065. wasn't a variable thing
Here is a field: Size
Line index: 7916
Here is a field: ihCS
Line index: 7917
Line: object table (section 3.1.1.1). wasn't a variable thing
Line: The color space is specified by either a LogColorSpace or LogColorSpaceW object ([MS-WMF] sections wasn't a variable thing
Line: 2.2.2.11 and 2.2.2.12, respectively). If the deleted color space is currently selected into the playback wasn't a variable thing
Line: device context, the default object MUST be restored. wasn't a variable thing
Line: An EMR_DELETEOBJECT record (section 2.3.8.3) SHOULD be used instead of this record to delete a wasn't a variable thing
Line: logical color space object. wasn't a variable thing
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Name: EMR_DELETECOLORSPACE
has_variable: False
fields: ['Type', 'Size', 'ihCS']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_DELETECOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Fields before: ['Type', 'Size', 'ihCS']
Fields after: ['ihCS']
Bullshit after...
Name: EMR_DELETECOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Line: The EMR_DELETEOBJECT record deletes a graphics object, which is specified by its index in the EMF wasn't a variable thing
Line: object table (section 3.1.1.1). wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihObject wasn't a variable thing
Here is a field: Type
Line index: 7938
Line: value is 0x00000028. wasn't a variable thing
Here is a field: Size
Line index: 7940
Line: 181 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: ihObject
Line index: 7946
Line: object table. wasn't a variable thing
Line: This value MUST NOT be 0, which is a reserved index that refers to the EMF metafile itself; and it wasn't a variable thing
Line: MUST NOT be the index of a stock object, which cannot be deleted. Stock object indexes are wasn't a variable thing
Line: specified in the StockObject (section 2.1.31) enumeration. wasn't a variable thing
Line: The object specified by this record MUST be deleted from the EMF object table. If the deleted object is wasn't a variable thing
Line: currently selected into the playback device context, the default object MUST be restored. wasn't a variable thing
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Name: EMR_DELETEOBJECT
has_variable: False
fields: ['Type', 'Size', 'ihObject']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_DELETEOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Fields before: ['Type', 'Size', 'ihObject']
Fields after: ['ihObject']
Bullshit after...
Name: EMR_DELETEOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Line: The EMR_RESIZEPALETTE record increases or decreases the size of an existing LogPalette object wasn't a variable thing
Line: (section 2.2.17). wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihPal wasn't a variable thing
Line: NumberOfEntries wasn't a variable thing
Here is a field: Type
Line index: 7968
Line: value is 0x00000033. wasn't a variable thing
Here is a field: Size
Line index: 7970
Here is a field: ihPal
Line index: 7971
Line: table (section 3.1.1.1). wasn't a variable thing
Here is a field: NumberOfEntries
Line index: 7973
Line: after resizing. The value MUST be <= 0x00000400 and > 0x00000000.<78> wasn't a variable thing
Line: The new size of the LogPalette object MUST be reflected in the NumberOfEntries field in that wasn't a variable thing
Line: structure. wasn't a variable thing
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Name: EMR_RESIZEPALETTE
has_variable: False
fields: ['Type', 'Size', 'ihPal', 'NumberOfEntries']
struct_format: ['4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_RESIZEPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'NumberOfEntries']
Fields before: ['Type', 'Size', 'ihPal', 'NumberOfEntries']
Fields after: ['ihPal', 'NumberOfEntries']
Bullshit after...
Name: EMR_RESIZEPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'NumberOfEntries']
Line: The EMR_SELECTOBJECT record selects a graphics object into the playback device context. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihObject wasn't a variable thing
Line: 182 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: Type
Line index: 7995
Line: value is 0x00000025. wasn't a variable thing
Here is a field: Size
Line index: 7997
Here is a field: ihObject
Line index: 7998
Line: EMF object table (section 3.1.1.1) or the index of a stock object in the StockObject enumeration wasn't a variable thing
Line: (section 2.1.31). wasn't a variable thing
Line: The object index MUST NOT be zero, which is reserved and refers to the EMF metafile itself. wasn't a variable thing
Line: The object specified by this record MUST be used in subsequent EMF drawing operations, until another wasn't a variable thing
Line: EMR_SELECTOBJECT record changes the object of that type or the object is deleted. wasn't a variable thing
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Name: EMR_SELECTOBJECT
has_variable: False
fields: ['Type', 'Size', 'ihObject']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SELECTOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Fields before: ['Type', 'Size', 'ihObject']
Fields after: ['ihObject']
Bullshit after...
Name: EMR_SELECTOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Line: The EMR_SELECTPALETTE record selects a logical palette into the playback device context. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihPal wasn't a variable thing
Here is a field: Type
Line index: 8017
Line: value is 0x00000030. wasn't a variable thing
Here is a field: Size
Line index: 8019
Line: 0x0000000C. wasn't a variable thing
Here is a field: ihPal
Line index: 8021
Line: 2.2.17) in the EMF object table (section 3.1.1.1) or the value DEFAULT_PALETTE from the wasn't a variable thing
Line: StockObject enumeration (section 2.1.31), which is the index of a stock palette. wasn't a variable thing
Line: The object index MUST NOT be zero, which is reserved and refers to the EMF metafile itself. wasn't a variable thing
Line: The palette specified by this record MUST be used in subsequent EMF drawing operations, until wasn't a variable thing
Line: another EMR_SELECTPALETTE record changes the object or the object is deleted. wasn't a variable thing
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Name: EMR_SELECTPALETTE
has_variable: False
fields: ['Type', 'Size', 'ihPal']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SELECTPALETTE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal']
Fields before: ['Type', 'Size', 'ihPal']
Fields after: ['ihPal']
Bullshit after...
Name: EMR_SELECTPALETTE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal']
Line: The EMR_SETCOLORSPACE record selects a logical color space into the playback device wasn't a variable thing
Line: context.<79> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: 183 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihCS wasn't a variable thing
Here is a field: Type
Line index: 8046
Line: value is 0x00000064. wasn't a variable thing
Here is a field: Size
Line index: 8048
Line: 0x0000000C. wasn't a variable thing
Here is a field: ihCS
Line index: 8050
Line: object table (section 3.1.1.1). wasn't a variable thing
Line: This object is either a LogColorSpace or LogColorSpaceW object ([MS-WMF] sections 2.2.2.11 and wasn't a variable thing
Line: 2.2.2.12, respectively). wasn't a variable thing
Line: The color space specified by this record MUST be used in subsequent EMF drawing operations, until wasn't a variable thing
Line: another EMR_SETCOLORSPACE record changes the object or the object is deleted. wasn't a variable thing
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Name: EMR_SETCOLORSPACE
has_variable: False
fields: ['Type', 'Size', 'ihCS']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETCOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Fields before: ['Type', 'Size', 'ihCS']
Fields after: ['ihCS']
Bullshit after...
Name: EMR_SETCOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Line: The EMR_SETPALETTEENTRIES record defines RGB color values in a range of entries for an existing wasn't a variable thing
Line: logical palette. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ihPal wasn't a variable thing
Line: Start wasn't a variable thing
Line: NumberofEntries wasn't a variable thing
Line: aPalEntries (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8074
Line: This value is 0x00000032. wasn't a variable thing
Here is a field: Size
Line index: 8076
Here is a field: ihPal
Line index: 8077
Line: the EMF object table (section 3.1.1.1). wasn't a variable thing
Here is a field: Start
Line index: 8079
Here is a field: NumberofEntries
Line index: 8080
Line: aPalEntries array. wasn't a variable thing
Line: 184 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: aPalEntries (variable): An array of LogPaletteEntry objects (section 2.2.18) that specify the palette WAS a variable thing
Line: data. wasn't a variable thing
Line: See section 2.3.8 for more object manipulation record types. wasn't a variable thing
Line: 2.3.9 OpenGL Record Types wasn't a variable thing
Line: The OpenGL record types specify OpenGL functions [OPENGL]. wasn't a variable thing
Line: The following are EMF OpenGL record types.<80> wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_GLSBOUNDEDRECORD 2.3.9.1 Specifies an OpenGL function with a bounding rectangle for output. wasn't a variable thing
Line: EMR_GLSRECORD 2.3.9.2 Specifies an OpenGL function. wasn't a variable thing
Line: The generic structure of OpenGL records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: OpenGLRecordBuffer (variable) WAS a variable thing
Line: ... wasn't a variable thing
Name: EMR_SETPALETTEENTRIES
has_variable: True
fields: ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries']
struct_format: ['4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SETPALETTEENTRIES
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries']
Fields before: ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries']
Fields after: ['ihPal', 'Start', 'NumberofEntries']
Bullshit after...
Name: EMR_SETPALETTEENTRIES
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries']
Line: The EMR_GLSBOUNDEDRECORD record specifies an OpenGL function with a bounding rectangle for wasn't a variable thing
Line: output. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: cbData wasn't a variable thing
Line: Data (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8158
Line: This value is 0x00000067. wasn't a variable thing
Here is a field: Bounds
Line index: 8160
Line: in logical units, for output produced by executing the OpenGL function. wasn't a variable thing
Here is a field: cbData
Line index: 8162
Line: is zero, no data is attached to this record. wasn't a variable thing
Line: Data (variable, optional): An array of bytes that specifies data for the OpenGL function. WAS a variable thing
Line: See section 2.3.9 for more OpenGL record types. wasn't a variable thing
Name: EMR_GLSBOUNDEDRECORD
has_variable: True
fields: ['Type', 'Bounds', 'cbData']
struct_format: ['4b', '16b', '4b']
Bullshit before...
Name: EMR_GLSBOUNDEDRECORD
Here is the struct format: ['4b', '16b', '4b']
Here is the fields: ['Type', 'Bounds', 'cbData']
Fields before: ['Type', 'Bounds', 'cbData']
Fields after: ['Bounds', 'cbData']
Bullshit after...
Name: EMR_GLSBOUNDEDRECORD
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'cbData']
Line: The EMR_GLSRECORD record specifies an OpenGL function. wasn't a variable thing
Line: Fields not specified in this section are specified in section 2.3.1. wasn't a variable thing
Line: 186 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: cbData wasn't a variable thing
Line: Data (variable, optional) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8186
Line: is 0x00000066. wasn't a variable thing
Here is a field: cbData
Line index: 8188
Line: is zero, no data is attached to this record. wasn't a variable thing
Line: Data (variable, optional): An array of bytes that specifies data for the OpenGL function. WAS a variable thing
Line: See section 2.3.9 for more OpenGL record types. wasn't a variable thing
Line: 2.3.10 Path Bracket Record Types wasn't a variable thing
Line: The Path Bracket record types are used to construct a path bracket, which defines the current path wasn't a variable thing
Line: in the playback device context. wasn't a variable thing
Line: Note: None of the path bracket records specify parameters. wasn't a variable thing
Line: The following are the path bracket record types. wasn't a variable thing
Line: Name Description wasn't a variable thing
Line: EMR_ABORTPATH This record closes path bracket construction and discards the current path. wasn't a variable thing
Line: EMR_BEGINPATH This record opens path bracket construction. wasn't a variable thing
Line: Once path bracket construction is open, an application can begin specifying records to wasn't a variable thing
Line: define the points that lie in the path. Path bracket construction MUST be closed by an wasn't a variable thing
Line: EMR_ABORTPATH or EMR_ENDPATH record. wasn't a variable thing
Line: When an application processes an EMR_BEGINPATH record, path bracket construction wasn't a variable thing
Line: MUST NOT be open. wasn't a variable thing
Line: EMR_CLOSEFIGURE This record closes the figure in path bracket construction. wasn't a variable thing
Line: Processing the EMR_CLOSEFIGURE record closes the figure by drawing a line from the wasn't a variable thing
Line: current drawing position to the first point of the figure, and then it connects the lines by wasn't a variable thing
Line: using the current line join. If the figure is closed by processing an EMR_LINETO record wasn't a variable thing
Line: (section 2.3.5.13) instead of this record, the current line cap is used to create the corner wasn't a variable thing
Line: instead of the line join. The line parameters are specified by the PenStyle field in the wasn't a variable thing
Line: current LogPen (section 2.2.19) and LogPenEx (section 2.2.20) objects. wasn't a variable thing
Line: The EMR_CLOSEFIGURE record SHOULD be used only if there is an open figure in the path wasn't a variable thing
Line: bracket. A figure in a path is open unless it is explicitly closed by processing this record. A wasn't a variable thing
Line: figure can be open even if the current point is the same as the starting point. wasn't a variable thing
Line: After processing the EMR_CLOSEFIGURE record, adding a line or curve to the path bracket wasn't a variable thing
Line: starts a new figure. wasn't a variable thing
Line: EMR_ENDPATH This record closes path bracket construction and selects the path into the playback device wasn't a variable thing
Line: 187 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Name Description wasn't a variable thing
Line: context. wasn't a variable thing
Line: EMR_FLATTENPATH This record transforms each curve in the current path into a sequence of lines. wasn't a variable thing
Line: EMR_WIDENPATH This record redefines the current path as the area that would be painted if its path were wasn't a variable thing
Line: drawn using the current pen. wasn't a variable thing
Line: The generic structure of path bracket records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Name: EMR_GLSRECORD
has_variable: True
fields: ['Type', 'cbData']
struct_format: ['4b', '4b']
Bullshit before...
Name: EMR_GLSRECORD
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'cbData']
Fields before: ['Type', 'cbData']
Fields after: ['cbData']
Bullshit after...
Name: EMR_GLSRECORD
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cbData']
Line: The EMR_COLORMATCHTOTARGETW record specifies whether to perform color matching with a wasn't a variable thing
Line: color profile that is specified in a file with a name consisting of Unicode characters.<81> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: dwAction wasn't a variable thing
Line: dwFlags wasn't a variable thing
Line: cbName wasn't a variable thing
Line: cbData wasn't a variable thing
Line: Data (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8419
Line: EMR_COLORMATCHTOTARGETW. This value is 0x00000079. wasn't a variable thing
Here is a field: Size
Line index: 8421
Here is a field: dwAction
Line index: 8422
Line: (section 2.1.7). wasn't a variable thing
Here is a field: dwFlags
Line index: 8424
Line: enumeration (section 2.1.6). wasn't a variable thing
Here is a field: cbName
Line index: 8426
Line: name of the target color profile. wasn't a variable thing
Here is a field: cbData
Line index: 8428
Line: profile in the Data field. wasn't a variable thing
Line: Data (variable): An array of size (cbName + cbData) bytes, which specifies the UTF16-LE name WAS a variable thing
Line: and raw data of the target color profile. wasn't a variable thing
Line: An EMR_COLORMATCHTOTARGETW record can be used to control whether to apply the current color wasn't a variable thing
Line: transform to subsequent graphics operations. If the dwAction field value is CS_ENABLE, color wasn't a variable thing
Line: mapping is enabled, and the current color transform SHOULD be applied. If dwAction is set to wasn't a variable thing
Line: CS_DISABLE, the color transform SHOULD NOT be applied. wasn't a variable thing
Line: 192 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Before applying the current color transform, WCS SHOULD be enabled in the playback device wasn't a variable thing
Line: context.<82> wasn't a variable thing
Line: While color mapping to the target is enabled by a dwAction value of CS_ENABLE, changes to the wasn't a variable thing
Line: color space or color gamut mapping are not applied. However, those changes MUST take effect wasn't a variable thing
Line: when color mapping to the target is disabled. wasn't a variable thing
Line: The dwAction field SHOULD NOT be set to CS_DELETE_TRANSFORM unless color management has wasn't a variable thing
Line: already been enabled with an EMR_SETICMMODE record (section 2.3.11.14). wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_COLORMATCHTOTARGETW
has_variable: True
fields: ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_COLORMATCHTOTARGETW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData']
Fields before: ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData']
Fields after: ['dwAction', 'dwFlags', 'cbName', 'cbData']
Bullshit after...
Name: EMR_COLORMATCHTOTARGETW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData']
Line: The EMR_FORCEUFIMAPPING record forces the font mapper to match fonts based on their wasn't a variable thing
Line: UniversalFontId in preference to their LogFont (section 2.2.13) information. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ufi wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8463
Line: value is 0x0000006D. wasn't a variable thing
Here is a field: Size
Line index: 8465
Here is a field: ufi
Line index: 8466
Line: See section 2.3.5 for more drawing record types. wasn't a variable thing
Name: EMR_FORCEUFIMAPPING
has_variable: False
fields: ['Type', 'Size', 'ufi']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_FORCEUFIMAPPING
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'ufi']
Fields before: ['Type', 'Size', 'ufi']
Fields after: ['ufi']
Bullshit after...
Name: EMR_FORCEUFIMAPPING
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'ufi']
Line: The EMR_INVERTRGN record inverts the colors in the specified region. The current clipping regions wasn't a variable thing
Line: used by this record are maintained in a Regions state element (section 3.1.1.2.1) in the playback wasn't a variable thing
Line: device context (section 3.1). wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Bounds wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: 193 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Line: RgnDataSize wasn't a variable thing
Line: RgnData (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8493
Line: is 0x00000049. wasn't a variable thing
Here is a field: Size
Line index: 8495
Here is a field: Bounds
Line index: 8496
Line: bounding rectangle in logical coordinates. If the intersection of this rectangle with the current wasn't a variable thing
Line: clipping region is empty, this record has no effect. wasn't a variable thing
Here is a field: RgnDataSize
Line index: 8499
Line: RgnData (variable): A RgnDataSize length array of bytes that specifies the output region in a WAS a variable thing
Line: RegionData object (section 2.2.24). The bounds specified by the RegionDataHeader field of wasn't a variable thing
Line: this object MAY<83> be used as the bounding rectangle of the region when this record is wasn't a variable thing
Line: processed. wasn't a variable thing
Line: If the output surface is monochrome, this record SHOULD convert white pixels to black and black wasn't a variable thing
Line: pixels to white. For color output, the inversion is dependent on the type of technology used to wasn't a variable thing
Line: generate the colors. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_INVERTRGN
has_variable: True
fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
struct_format: ['4b', '4b', '16b', '4b']
Bullshit before...
Name: EMR_INVERTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields after: ['Bounds', 'RgnDataSize']
Bullshit after...
Name: EMR_INVERTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Line: The EMR_MOVETOEX record specifies the coordinates of s new drawing position in logical units. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Offset wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8521
Line: is 0x0000001B. wasn't a variable thing
Here is a field: Size
Line index: 8523
Here is a field: Offset
Line index: 8524
Line: new drawing position in logical units. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Line: 194 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_MOVETOEX
has_variable: False
fields: ['Type', 'Size', 'Offset']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_MOVETOEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Offset']
Fields before: ['Type', 'Size', 'Offset']
Fields after: ['Offset']
Bullshit after...
Name: EMR_MOVETOEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Offset']
Line: The EMR_PIXELFORMAT record specifies the pixel format to use for graphics operations.<84> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: pfd (40 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8547
Line: value is 0x00000068. wasn't a variable thing
Here is a field: Size
Line index: 8549
Here is a field: pfd
Line index: 8550
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_PIXELFORMAT
has_variable: False
fields: ['Type', 'Size', 'pfd']
struct_format: ['4b', '4b', '40b']
Bullshit before...
Name: EMR_PIXELFORMAT
Here is the struct format: ['4b', '4b', '40b']
Here is the fields: ['Type', 'Size', 'pfd']
Fields before: ['Type', 'Size', 'pfd']
Fields after: ['pfd']
Bullshit after...
Name: EMR_PIXELFORMAT
Here is the struct format: ['4b', '4b', '40b']
Here is the fields: ['Type', 'Size', 'pfd']
Line: The EMR_RESTOREDC record restores the playback device context to the specified state. The wasn't a variable thing
Line: playback device context is restored by popping state information off a stack that was created by a wasn't a variable thing
Line: prior EMR_SAVEDC record (section 2.3.11). wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: SavedDC wasn't a variable thing
Here is a field: Type
Line index: 8566
Line: is 0x00000022. wasn't a variable thing
Here is a field: Size
Line index: 8568
Line: 0x0000000C. wasn't a variable thing
Here is a field: SavedDC
Line index: 8570
Line: state. This value MUST be negative; –1 represents the state that was most recently saved on the wasn't a variable thing
Line: stack, –2 the one before that, etc. wasn't a variable thing
Line: The stack can contain state information for multiple instances of the playback device context. When a wasn't a variable thing
Line: state is restored, all state instances that were saved more recently MUST be discarded. wasn't a variable thing
Line: 195 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_RESTOREDC
has_variable: False
fields: ['Type', 'Size', 'SavedDC']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_RESTOREDC
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'SavedDC']
Fields before: ['Type', 'Size', 'SavedDC']
Fields after: ['SavedDC']
Bullshit after...
Name: EMR_RESTOREDC
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'SavedDC']
Line: The EMR_SCALEVIEWPORTEXTEX record specifies the current viewport in the playback device wasn't a variable thing
Line: context by using ratios formed by the specified multiplicands and divisors. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: xNum wasn't a variable thing
Line: xDenom wasn't a variable thing
Line: yNum wasn't a variable thing
Line: yDenom wasn't a variable thing
Here is a field: Type
Line index: 8597
Line: This value is 0x0000001F. wasn't a variable thing
Here is a field: Size
Line index: 8599
Here is a field: xNum
Line index: 8600
Here is a field: xDenom
Line index: 8601
Here is a field: yNum
Line index: 8602
Here is a field: yDenom
Line index: 8603
Line: The extent MUST NOT be changed if the current mapping mode (section 2.1.21) is fixed scale. Only wasn't a variable thing
Line: MM_ISOTROPIC and MM_ANISOTROPIC are not fixed scale. wasn't a variable thing
Line: The new viewport extent is computed as follows. wasn't a variable thing
Line: xNewWE = (xOldWE * xNum) / xDenom wasn't a variable thing
Line: yNewWE = (yOldWE * yNum) / yDenom wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SCALEVIEWPORTEXTEX
has_variable: False
fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SCALEVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields before: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields after: ['xNum', 'xDenom', 'yNum', 'yDenom']
Bullshit after...
Name: EMR_SCALEVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Line: The EMR_SCALEWINDOWEXTEX record specifies the current window in the playback device wasn't a variable thing
Line: context by using ratios formed by the specified multiplicands and divisors. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: 196 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Size wasn't a variable thing
Line: xNum wasn't a variable thing
Line: xDenom wasn't a variable thing
Line: yNum wasn't a variable thing
Line: yDenom wasn't a variable thing
Here is a field: Type
Line index: 8631
Line: This value is 0x00000020. wasn't a variable thing
Here is a field: Size
Line index: 8633
Here is a field: xNum
Line index: 8634
Here is a field: xDenom
Line index: 8635
Here is a field: yNum
Line index: 8636
Here is a field: yDenom
Line index: 8637
Line: The extent MUST NOT be changed if the current mapping mode (section 2.1.21) is fixed scale. Only wasn't a variable thing
Line: MM_ISOTROPIC and MM_ANISOTROPIC are not fixed scale. wasn't a variable thing
Line: The new window extent is computed as follows. wasn't a variable thing
Line: xNewWE = (xOldWE * xNum) / xDenom wasn't a variable thing
Line: yNewWE = (yOldWE * yNum) / yDenom wasn't a variable thing
Line:  wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SCALEWINDOWEXTEX
has_variable: False
fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
struct_format: ['4b', '4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SCALEWINDOWEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields before: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields after: ['xNum', 'xDenom', 'yNum', 'yDenom']
Bullshit after...
Name: EMR_SCALEWINDOWEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Line: The EMR_SETARCDIRECTION record specifies the drawing direction to be used for arc and rectangle wasn't a variable thing
Line: output. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ArcDirection wasn't a variable thing
Here is a field: Type
Line index: 8658
Line: value is 0x00000039. wasn't a variable thing
Here is a field: Size
Line index: 8660
Line: 0x0000000C. wasn't a variable thing
Line: 197 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: ArcDirection
Line index: 8667
Line: ArcDirection enumeration (section 2.1.2). The default direction is counterclockwise. wasn't a variable thing
Line: The arc direction affects the direction in which the following records draw: wasn't a variable thing
Line:  EMR_ARC (section 2.3.5.2) wasn't a variable thing
Line:  EMR_ARCTO (section 2.3.5.3) wasn't a variable thing
Line:  EMR_CHORD (section 2.3.5.4) wasn't a variable thing
Line:  EMR_ELLIPSE (section 2.3.5.5) wasn't a variable thing
Line:  EMR_PIE (section 2.3.5.15) wasn't a variable thing
Line:  EMR_RECTANGLE (section 2.3.5.34) wasn't a variable thing
Line:  EMR_ROUNDRECT (section 2.3.5.35) wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETARCDIRECTION
has_variable: False
fields: ['Type', 'Size', 'ArcDirection']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETARCDIRECTION
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ArcDirection']
Fields before: ['Type', 'Size', 'ArcDirection']
Fields after: ['ArcDirection']
Bullshit after...
Name: EMR_SETARCDIRECTION
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ArcDirection']
Line: The EMR_SETBKCOLOR record specifies the background color for text output. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Color wasn't a variable thing
Here is a field: Type
Line index: 8690
Line: is 0x00000019. wasn't a variable thing
Here is a field: Size
Line index: 8692
Here is a field: Color
Line index: 8693
Line: value. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETBKCOLOR
has_variable: False
fields: ['Type', 'Size', 'Color']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETBKCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Fields before: ['Type', 'Size', 'Color']
Fields after: ['Color']
Bullshit after...
Name: EMR_SETBKCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Line: The EMR_SETBKMODE record specifies the background mix mode to use with text, hatched brushes, wasn't a variable thing
Line: and pens that are not solid lines. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: BackgroundMode wasn't a variable thing
Line: 198 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: Type
Line index: 8714
Line: is 0x00000012. wasn't a variable thing
Here is a field: Size
Line index: 8716
Here is a field: BackgroundMode
Line index: 8717
Line: BackgroundMode enumeration (section 2.1.4). wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETBKMODE
has_variable: False
fields: ['Type', 'Size', 'BackgroundMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETBKMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'BackgroundMode']
Fields before: ['Type', 'Size', 'BackgroundMode']
Fields after: ['BackgroundMode']
Bullshit after...
Name: EMR_SETBKMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'BackgroundMode']
Line: The EMR_SETBRUSHORGEX record specifies the origin of the current brush. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Origin wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8733
Line: value is 0x0000000D. wasn't a variable thing
Here is a field: Size
Line index: 8735
Here is a field: Origin
Line index: 8736
Line: vertical origin of the current brush in logical units. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETBRUSHORGEX
has_variable: False
fields: ['Type', 'Size', 'Origin']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_SETBRUSHORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Fields before: ['Type', 'Size', 'Origin']
Fields after: ['Origin']
Bullshit after...
Name: EMR_SETBRUSHORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Line: The EMR_SETCOLORADJUSTMENT record specifies color adjustment properties in the playback wasn't a variable thing
Line: device context. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ColorAdjustment (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: 199 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: Type
Line index: 8760
Line: EMR_SETCOLORADJUSTMENT. This value is 0x00000017. wasn't a variable thing
Here is a field: Size
Line index: 8762
Line: 0x00000020. wasn't a variable thing
Here is a field: ColorAdjustment
Line index: 8764
Line: adjustment values. wasn't a variable thing
Line: Color adjustment values are used to adjust the input color of the source bitmap for graphics wasn't a variable thing
Line: operations performed by EMR_STRETCHBLT and EMR_STRETCHDIBITS records when wasn't a variable thing
Line: STRETCH_HALFTONE mode is set from the StretchMode enumeration (section 2.1.32). wasn't a variable thing
Line: The ColorAdjustment object specified by this record MUST be used in graphics operations that require wasn't a variable thing
Line: a ColorAdjustment object, until a different ColorAdjustment object is specified by another wasn't a variable thing
Line: EMR_SETCOLORADJUSTMENT record, or until the object is removed by a EMR_DELETEOBJECT record. wasn't a variable thing
Line: See section 2.3.11 more state record types. wasn't a variable thing
Name: EMR_SETCOLORADJUSTMENT
has_variable: False
fields: ['Type', 'Size', 'ColorAdjustment']
struct_format: ['4b', '4b', '24b']
Bullshit before...
Name: EMR_SETCOLORADJUSTMENT
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'ColorAdjustment']
Fields before: ['Type', 'Size', 'ColorAdjustment']
Fields after: ['ColorAdjustment']
Bullshit after...
Name: EMR_SETCOLORADJUSTMENT
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'ColorAdjustment']
Line: The EMR_SETICMMODE record specifies the mode of Image Color Management (ICM) for wasn't a variable thing
Line: graphics operations.<85> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: ICMMode wasn't a variable thing
Here is a field: Type
Line index: 8786
Line: value is 0x00000062. wasn't a variable thing
Here is a field: Size
Line index: 8788
Line: 0x0000000C. wasn't a variable thing
Here is a field: ICMMode
Line index: 8790
Line: ICMMode enumeration (section 2.1.18). wasn't a variable thing
Line: When ICM mode is enabled in the playback device context, colors specified in EMF records SHOULD wasn't a variable thing
Line: be color matched, whereas the default color profile SHOULD be used when a bit-block transfer is wasn't a variable thing
Line: performed. If the default color profile is not desired, ICM mode SHOULD be turned off before wasn't a variable thing
Line: performing the bit-block transfer. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETICMMODE
has_variable: False
fields: ['Type', 'Size', 'ICMMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETICMMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ICMMode']
Fields before: ['Type', 'Size', 'ICMMode']
Fields after: ['ICMMode']
Bullshit after...
Name: EMR_SETICMMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ICMMode']
Line: The EMR_SETICMPROFILEA record specifies a color profile in a file with a name consisting of wasn't a variable thing
Line: ASCII characters, for graphics output.<86> wasn't a variable thing
Line: 200 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: dwFlags wasn't a variable thing
Line: cbName wasn't a variable thing
Line: cbData wasn't a variable thing
Line: Data (variable) WAS a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8819
Line: value is 0x00000070. wasn't a variable thing
Here is a field: Size
Line index: 8821
Here is a field: dwFlags
Line index: 8822
Here is a field: cbName
Line index: 8823
Line: desired color profile. wasn't a variable thing
Here is a field: cbData
Line index: 8825
Line: contained in the Data field. wasn't a variable thing
Line: Data (variable): An array of size (cbName + cbData) in bytes, which specifies the ASCII name and WAS a variable thing
Line: raw data of the desired color profile. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETICMPROFILEA
has_variable: True
fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
struct_format: ['4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SETICMPROFILEA
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields before: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields after: ['dwFlags', 'cbName', 'cbData']
Bullshit after...
Name: EMR_SETICMPROFILEA
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Line: The EMR_SETICMPROFILEW record specifies a color profile in a file with a name consisting of wasn't a variable thing
Line: Unicode characters, for graphics output.<87> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: dwFlags wasn't a variable thing
Line: cbName wasn't a variable thing
Line: cbData wasn't a variable thing
Line: Data (variable) WAS a variable thing
Line: 201 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8852
Line: This value is 0x00000071. wasn't a variable thing
Here is a field: Size
Line index: 8854
Here is a field: dwFlags
Line index: 8855
Here is a field: cbName
Line index: 8856
Line: name of the desired color profile. wasn't a variable thing
Here is a field: cbData
Line index: 8858
Line: Data (variable): An array of size (cbName + cbData) in bytes, which specifies the UTF16-LE name WAS a variable thing
Line: and raw data of the desired color profile. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETICMPROFILEW
has_variable: True
fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
struct_format: ['4b', '4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SETICMPROFILEW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields before: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields after: ['dwFlags', 'cbName', 'cbData']
Bullshit after...
Name: EMR_SETICMPROFILEW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Line: The EMR_SETLAYOUT record specifies the order in which text and graphics are drawn.<88> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: LayoutMode wasn't a variable thing
Here is a field: Type
Line index: 8874
Line: is 0x00000073. wasn't a variable thing
Here is a field: Size
Line index: 8876
Line: 0x0000000C. wasn't a variable thing
Here is a field: LayoutMode
Line index: 8878
Line: Value Meaning wasn't a variable thing
Line: LAYOUT_LTR wasn't a variable thing
Line: 0x00000000 wasn't a variable thing
Line: Sets the default horizontal layout to be left-to-right. This is the wasn't a variable thing
Line: default mode for English and European locales. wasn't a variable thing
Line: LAYOUT_RTL wasn't a variable thing
Line: 0x00000001 wasn't a variable thing
Line: Sets the default horizontal layout to be right-to-left. This mode is wasn't a variable thing
Line: required for some languages, including Arabic and Hebrew. wasn't a variable thing
Line: LAYOUT_BITMAPORIENTATIONPRESERVED wasn't a variable thing
Line: 0x00000008 wasn't a variable thing
Line: Disables mirroring of bitmaps that are drawn by bitmap records wasn't a variable thing
Line: (section 2.3.1) when the layout mode is right-to-left. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Line: 202 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_SETLAYOUT
has_variable: False
fields: ['Type', 'Size', 'LayoutMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETLAYOUT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'LayoutMode']
Fields before: ['Type', 'Size', 'LayoutMode']
Fields after: ['LayoutMode']
Bullshit after...
Name: EMR_SETLAYOUT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'LayoutMode']
Line: The EMR_SETLINKEDUFIS record sets the UniversalFontIds (section 2.2.27) of linked fonts to use wasn't a variable thing
Line: during character lookup. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: uNumLinkedUFI wasn't a variable thing
Line: ufis (variable) WAS a variable thing
Line: ... wasn't a variable thing
Line: Reserved wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 8915
Line: value is 0x00000077. wasn't a variable thing
Here is a field: Size
Line index: 8917
Here is a field: uNumLinkedUFI
Line index: 8918
Line: ufis (variable): An array of uNumLinkedUFI elements of type UniversalFontId (section 2.2.27), WAS a variable thing
Line: which specifies the identifiers of the linked fonts. wasn't a variable thing
Here is a field: Reserved
Line index: 8921
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETLINKEDUFIS
has_variable: True
fields: ['Type', 'Size', 'uNumLinkedUFI', 'Reserved']
struct_format: ['4b', '4b', '4b', '8b']
Bullshit before...
Name: EMR_SETLINKEDUFIS
Here is the struct format: ['4b', '4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'uNumLinkedUFI', 'Reserved']
Fields before: ['Type', 'Size', 'uNumLinkedUFI', 'Reserved']
Fields after: ['uNumLinkedUFI', 'Reserved']
Bullshit after...
Name: EMR_SETLINKEDUFIS
Here is the struct format: ['4b', '4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'uNumLinkedUFI', 'Reserved']
Line: The EMR_SETMAPMODE record specifies the current mapping mode, which specifies the unit of wasn't a variable thing
Line: measure used to transform page space units into device space units, and also specifies the wasn't a variable thing
Line: orientation of the device's x-axis and y-axis. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: MapMode wasn't a variable thing
Here is a field: Type
Line index: 8937
Line: value is 0x00000011. wasn't a variable thing
Here is a field: Size
Line index: 8939
Line: 203 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: MapMode
Line index: 8945
Line: MM_TEXT mode allows applications to work in device pixels, whose size varies from device to device. wasn't a variable thing
Line: The MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC, and MM_TWIPS wasn't a variable thing
Line: modes are useful for applications drawing in physically meaningful units such as inches or millimeters. wasn't a variable thing
Line: MM_ISOTROPIC mode ensures a 1:1 aspect ratio. wasn't a variable thing
Line: MM_ANISOTROPIC mode allows the x-coordinates and y-coordinates to be adjusted independently. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETMAPMODE
has_variable: False
fields: ['Type', 'Size', 'MapMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETMAPMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MapMode']
Fields before: ['Type', 'Size', 'MapMode']
Fields after: ['MapMode']
Bullshit after...
Name: EMR_SETMAPMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MapMode']
Line: The EMR_SETMAPPERFLAGS record specifies parameters for the process of matching logical fonts to wasn't a variable thing
Line: physical fonts, which is performed by the font mapper.<89> wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Flags wasn't a variable thing
Here is a field: Type
Line index: 8965
Line: value is 0x00000010. wasn't a variable thing
Here is a field: Size
Line index: 8967
Line: 0x0000000C. wasn't a variable thing
Here is a field: Flags
Line index: 8969
Line: Value Meaning wasn't a variable thing
Line: 0x00000000 The font mapper is not limited to fonts that match the aspect ratio of the output device. wasn't a variable thing
Line: 0x00000001 The font mapper SHOULD select only fonts that match the aspect ratio of the output device. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETMAPPERFLAGS
has_variable: False
fields: ['Type', 'Size', 'Flags']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETMAPPERFLAGS
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Flags']
Fields before: ['Type', 'Size', 'Flags']
Fields after: ['Flags']
Bullshit after...
Name: EMR_SETMAPPERFLAGS
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Flags']
Line: The EMR_SETMITERLIMIT record specifies the limit for the length of miter joins. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: MiterLimit wasn't a variable thing
Line: 204 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Here is a field: Type
Line index: 8991
Line: value is 0x0000003A. wasn't a variable thing
Here is a field: Size
Line index: 8993
Here is a field: MiterLimit
Line index: 8994
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETMITERLIMIT
has_variable: False
fields: ['Type', 'Size', 'MiterLimit']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETMITERLIMIT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MiterLimit']
Fields before: ['Type', 'Size', 'MiterLimit']
Fields after: ['MiterLimit']
Bullshit after...
Name: EMR_SETMITERLIMIT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MiterLimit']
Line: The EMR_SETPOLYFILLMODE record defines polygon fill mode. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: PolygonFillMode wasn't a variable thing
Here is a field: Type
Line index: 9008
Line: value is 0x00000013. wasn't a variable thing
Here is a field: Size
Line index: 9010
Here is a field: PolygonFillMode
Line index: 9011
Line: PolygonFillMode (section 2.1.27) enumeration. wasn't a variable thing
Line: In general, the modes differ only in cases where a complex, overlapping polygon MUST be filled; for wasn't a variable thing
Line: example, a five-sided polygon that forms a five-pointed star with a pentagon in the center. In such wasn't a variable thing
Line: cases, ALTERNATE mode SHOULD fill every other enclosed region within the polygon (the points of wasn't a variable thing
Line: the star), but WINDING mode SHOULD fill all regions (the points of the star and the pentagon). wasn't a variable thing
Line: When the fill mode is ALTERNATE, the area between odd-numbered and even-numbered polygon sides wasn't a variable thing
Line: on each scan line SHOULD be filled. That is, the area between the first and second side SHOULD be wasn't a variable thing
Line: filled, and between the third and fourth side, and so on. wasn't a variable thing
Line: When the fill mode is WINDING, any region that has a nonzero winding value SHOULD be filled. The wasn't a variable thing
Line: winding value is the number of times a pen used to draw the polygon would go around the region. The wasn't a variable thing
Line: direction of each edge of the polygon is significant. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETPOLYFILLMODE
has_variable: False
fields: ['Type', 'Size', 'PolygonFillMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETPOLYFILLMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'PolygonFillMode']
Fields before: ['Type', 'Size', 'PolygonFillMode']
Fields after: ['PolygonFillMode']
Bullshit after...
Name: EMR_SETPOLYFILLMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'PolygonFillMode']
Line: The EMR_SETROP2 record defines a binary raster operation mode. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: 205 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: ROP2Mode wasn't a variable thing
Here is a field: Type
Line index: 9041
Line: 0x00000014. wasn't a variable thing
Here is a field: Size
Line index: 9043
Here is a field: ROP2Mode
Line index: 9044
Line: Binary Raster Op enumeration ([MS-WMF] section 2.1.1.2). wasn't a variable thing
Line: Binary raster operation mix modes define how to combine source and destination colors when drawing wasn't a variable thing
Line: with the current pen. The mix modes are binary raster operation codes, representing all possible wasn't a variable thing
Line: Boolean functions of two variables, using the binary operations AND, OR, and XOR (exclusive OR), wasn't a variable thing
Line: and the unary operation NOT. The mix mode is for raster devices only; it is not available for vector wasn't a variable thing
Line: devices. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETROP2
has_variable: False
fields: ['Type', 'Size', 'ROP2Mode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETROP2
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ROP2Mode']
Fields before: ['Type', 'Size', 'ROP2Mode']
Fields after: ['ROP2Mode']
Bullshit after...
Name: EMR_SETROP2
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ROP2Mode']
Line: The EMR_SETSTRETCHBLTMODE record specifies bitmap stretch mode. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: StretchMode wasn't a variable thing
Here is a field: Type
Line index: 9064
Line: EMR_SETSTRETCHBLTMODE. This value is 0x00000015. wasn't a variable thing
Here is a field: Size
Line index: 9066
Here is a field: StretchMode
Line index: 9067
Line: StretchMode enumeration. wasn't a variable thing
Line: The stretching mode specifies how to combine rows or columns of a bitmap with existing pixels on the wasn't a variable thing
Line: display device that the EMR_STRETCHBLT record is processed on. wasn't a variable thing
Line: The STRETCH_ANDSCANS and STRETCH_ORSCANS modes are typically used to preserve wasn't a variable thing
Line: foreground pixels in monochrome bitmaps. The STRETCH_DELETESCANS mode is typically used to wasn't a variable thing
Line: preserve color in color bitmaps. wasn't a variable thing
Line: The STRETCH_HALFTONE mode is slower and requires more processing of the source image than wasn't a variable thing
Line: the other three modes, but produces higher quality images. Also note that an EMR_SETBRUSHORGEX wasn't a variable thing
Line: SHOULD be encountered after setting the STRETCH_HALFTONE mode to avoid brush misalignment. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETSTRETCHBLTMODE
has_variable: False
fields: ['Type', 'Size', 'StretchMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETSTRETCHBLTMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'StretchMode']
Fields before: ['Type', 'Size', 'StretchMode']
Fields after: ['StretchMode']
Bullshit after...
Name: EMR_SETSTRETCHBLTMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'StretchMode']
Line: The EMR_SETTEXTALIGN record specifies text alignment for text drawing. wasn't a variable thing
Line: 206 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: TextAlignmentMode wasn't a variable thing
Here is a field: Type
Line index: 9095
Line: value is 0x00000016. wasn't a variable thing
Here is a field: Size
Line index: 9097
Here is a field: TextAlignmentMode
Line index: 9098
Line: of text alignment flags. These are either TextAlignmentMode flags ([MS-WMF] section 2.1.2.3) for wasn't a variable thing
Line: text with a horizontal baseline, or VerticalTextAlignmentMode flags ([MS-WMF] section 2.1.2.4) for wasn't a variable thing
Line: text with a vertical baseline. Only one value can be chosen from those that affect horizontal and wasn't a variable thing
Line: vertical alignment. wasn't a variable thing
Line: The EMR_SMALLTEXTOUT, EMR_EXTTEXTOUTA, and EMR_EXTTEXTOUTW records (section 2.3.5) use wasn't a variable thing
Line: text alignment values to position a string of text on the output medium. The values specify the wasn't a variable thing
Line: relationship between a reference point and a rectangle that bounds the text. The reference point is wasn't a variable thing
Line: either the current drawing position or a point passed to a text output record. wasn't a variable thing
Line: The rectangle that bounds the text is formed by the character cells in the text string. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETTEXTALIGN
has_variable: False
fields: ['Type', 'Size', 'TextAlignmentMode']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETTEXTALIGN
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'TextAlignmentMode']
Fields before: ['Type', 'Size', 'TextAlignmentMode']
Fields after: ['TextAlignmentMode']
Bullshit after...
Name: EMR_SETTEXTALIGN
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'TextAlignmentMode']
Line: The EMR_SETTEXTCOLOR record defines the current text foreground color. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Color wasn't a variable thing
Here is a field: Type
Line index: 9121
Line: value is 0x00000018. wasn't a variable thing
Here is a field: Size
Line index: 9123
Here is a field: Color
Line index: 9124
Line: color. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETTEXTCOLOR
has_variable: False
fields: ['Type', 'Size', 'Color']
struct_format: ['4b', '4b', '4b']
Bullshit before...
Name: EMR_SETTEXTCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Fields before: ['Type', 'Size', 'Color']
Fields after: ['Color']
Bullshit after...
Name: EMR_SETTEXTCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Line: The EMR_SETTEXTJUSTIFICATION record specifies the amount of extra space to add to break wasn't a variable thing
Line: characters for text justification.<91> wasn't a variable thing
Line: 207 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: nBreakExtra wasn't a variable thing
Line: nBreakCount wasn't a variable thing
Here is a field: Type
Line index: 9146
Line: This value is 0x00000078. wasn't a variable thing
Here is a field: Size
Line index: 9148
Here is a field: nBreakExtra
Line index: 9149
Line: logical units. wasn't a variable thing
Here is a field: nBreakCount
Line index: 9151
Line: Instead of using this record, an implementation SHOULD use EMR_EXTTEXTOUTW (section 2.3.5.8) to wasn't a variable thing
Line: perform this function. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETTEXTJUSTIFICATION
has_variable: False
fields: ['Type', 'Size', 'nBreakExtra', 'nBreakCount']
struct_format: ['4b', '4b', '4b', '4b']
Bullshit before...
Name: EMR_SETTEXTJUSTIFICATION
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'nBreakExtra', 'nBreakCount']
Fields before: ['Type', 'Size', 'nBreakExtra', 'nBreakCount']
Fields after: ['nBreakExtra', 'nBreakCount']
Bullshit after...
Name: EMR_SETTEXTJUSTIFICATION
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'nBreakExtra', 'nBreakCount']
Line: The EMR_SETVIEWPORTEXTEX record defines the viewport extent. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Extent wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 9168
Line: This value is 0x0000000B. wasn't a variable thing
Here is a field: Size
Line index: 9170
Here is a field: Extent
Line index: 9171
Line: vertical extents in device units. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETVIEWPORTEXTEX
has_variable: False
fields: ['Type', 'Size', 'Extent']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_SETVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Fields before: ['Type', 'Size', 'Extent']
Fields after: ['Extent']
Bullshit after...
Name: EMR_SETVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Line: The EMR_SETVIEWPORTORGEX record defines the viewport origin. wasn't a variable thing
Line: 208 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Origin wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 9192
Line: This value is 0x0000000C. wasn't a variable thing
Here is a field: Size
Line index: 9194
Here is a field: Origin
Line index: 9195
Line: and vertical origin in device units. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETVIEWPORTORGEX
has_variable: False
fields: ['Type', 'Size', 'Origin']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_SETVIEWPORTORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Fields before: ['Type', 'Size', 'Origin']
Fields after: ['Origin']
Bullshit after...
Name: EMR_SETVIEWPORTORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Line: The EMR_SETWINDOWEXTEX record defines the window extent. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Extent wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 9211
Line: value is 0x00000009. wasn't a variable thing
Here is a field: Size
Line index: 9213
Here is a field: Extent
Line index: 9214
Line: vertical extents in logical units. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Name: EMR_SETWINDOWEXTEX
has_variable: False
fields: ['Type', 'Size', 'Extent']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_SETWINDOWEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Fields before: ['Type', 'Size', 'Extent']
Fields after: ['Extent']
Bullshit after...
Name: EMR_SETWINDOWEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Line: The EMR_SETWINDOWORGEX record defines the window origin. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: 209 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Line: Size wasn't a variable thing
Line: Origin wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 9235
Line: This value is 0x0000000A. wasn't a variable thing
Here is a field: Size
Line index: 9237
Here is a field: Origin
Line index: 9238
Line: and vertical origin in logical units. wasn't a variable thing
Line: See section 2.3.11 for more state record types. wasn't a variable thing
Line: 2.3.12 Transform Record Types wasn't a variable thing
Line: The transform record types specify and modify world-space to page-space transforms. wasn't a variable thing
Line: The following are EMF transform record types. wasn't a variable thing
Line: Name Section Description wasn't a variable thing
Line: EMR_MODIFYWORLDTRANSFORM 2.3.12.1 Modifies the current world-space to page-space transform. wasn't a variable thing
Line: EMR_SETWORLDTRANSFORM 2.3.12.2 Specifies a two-dimensional linear transform between world space wasn't a variable thing
Line: and page space. wasn't a variable thing
Line: The generic structure of EMF transform records is specified as follows. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Xform (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: TransformData (optional) wasn't a variable thing
Name: EMR_SETWINDOWORGEX
has_variable: False
fields: ['Type', 'Size', 'Origin']
struct_format: ['4b', '4b', '8b']
Bullshit before...
Name: EMR_SETWINDOWORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Fields before: ['Type', 'Size', 'Origin']
Fields after: ['Origin']
Bullshit after...
Name: EMR_SETWINDOWORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Line: The EMR_MODIFYWORLDTRANSFORM record modifies the current world-space to page-space wasn't a variable thing
Line: transform in the playback device context. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Xform (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ModifyWorldTransformMode wasn't a variable thing
Here is a field: Type
Line index: 9298
Line: EMR_MODIFYWORLDTRANSFORM. This value is 0x00000024. wasn't a variable thing
Here is a field: Size
Line index: 9300
Line: 0x00000024. wasn't a variable thing
Here is a field: Xform
Line index: 9302
Line: in logical units. This transform is used according to the ModifyWorldTransformMode to define a wasn't a variable thing
Line: new value for the world-space to page-space transform in the playback device context. wasn't a variable thing
Here is a field: ModifyWorldTransformMode
Line index: 9305
Line: specified in Xform is used. This value is in the ModifyWorldTransformMode enumeration (section wasn't a variable thing
Line: 2.1.24). wasn't a variable thing
Line: For more information concerning transforms and coordinate spaces, see [MSDN-WRLDPGSPC]. See wasn't a variable thing
Line: section 2.3.12 for more transform record types. wasn't a variable thing
Line: 211 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_MODIFYWORLDTRANSFORM
has_variable: False
fields: ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode']
struct_format: ['4b', '4b', '24b', '4b']
Bullshit before...
Name: EMR_MODIFYWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b', '4b']
Here is the fields: ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode']
Fields before: ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode']
Fields after: ['Xform', 'ModifyWorldTransformMode']
Bullshit after...
Name: EMR_MODIFYWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b', '4b']
Here is the fields: ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode']
Line: The EMR_SETWORLDTRANSFORM record specifies a transform for the current world-space to pagespace transform in the playback device context. wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 1 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 2 wasn't a variable thing
Line: 0 1 2 3 4 5 6 7 8 9 wasn't a variable thing
Line: 3 wasn't a variable thing
Line: 0 1 wasn't a variable thing
Line: Type wasn't a variable thing
Line: Size wasn't a variable thing
Line: Xform (24 bytes) wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Line: ... wasn't a variable thing
Here is a field: Type
Line index: 9330
Line: EMR_SETWORLDTRANSFORM. This value is 0x00000023. wasn't a variable thing
Here is a field: Size
Line index: 9332
Line: 0x00000020. wasn't a variable thing
Here is a field: Xform
Line index: 9334
Line: transform in logical units. This transform defines a new value for the current world-space to pagespace transform. wasn't a variable thing
Line: For more information concerning transforms and coordinate spaces, see [MSDN-WRLDPGSPC]. See wasn't a variable thing
Line: section 2.3.12 for more transform record types. wasn't a variable thing
Line: 212 / 282 wasn't a variable thing
Line: [MS-EMF] - v20240423 wasn't a variable thing
Line: Enhanced Metafile Format wasn't a variable thing
Line: Copyright © 2024 Microsoft Corporation wasn't a variable thing
Line: Release: April 23, 2024 wasn't a variable thing
Name: EMR_SETWORLDTRANSFORM
has_variable: False
fields: ['Type', 'Size', 'Xform']
struct_format: ['4b', '4b', '24b']
Bullshit before...
Name: EMR_SETWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'Xform']
Fields before: ['Type', 'Size', 'Xform']
Fields after: ['Xform']
Bullshit after...
Name: EMR_SETWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'Xform']
class EMR_ALPHABLEND:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_ALPHABLEND"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ALPHABLEND {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_BITBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_BITBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_BITBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_MASKBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '2b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_MASKBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_MASKBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PLGBLT:
    format = ['4b', '4b', '16b', '24b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_PLGBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PLGBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETDIBITSTODEVICE:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETDIBITSTODEVICE"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETDIBITSTODEVICE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STRETCHBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_STRETCHBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STRETCHBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STRETCHDIBITS:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_STRETCHDIBITS"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STRETCHDIBITS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_TRANSPARENTBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_TRANSPARENTBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_TRANSPARENTBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXCLUDECLIPRECT:
    format = ['4b', '4b', '16b']
    name = "EMR_EXCLUDECLIPRECT"
    has_variable = False
    fields = ['Type', 'Size', 'Clip'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXCLUDECLIPRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTSELECTCLIPRGN:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_EXTSELECTCLIPRGN"
    has_variable = True
    fields = ['Type', 'Size', 'RgnDataSize', 'RegionMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTSELECTCLIPRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_INTERSECTCLIPRECT:
    format = ['4b', '4b', '16b']
    name = "EMR_INTERSECTCLIPRECT"
    has_variable = False
    fields = ['Type', 'Size', 'Clip'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_INTERSECTCLIPRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_OFFSETCLIPRGN:
    format = ['4b', '4b', '8b']
    name = "EMR_OFFSETCLIPRGN"
    has_variable = False
    fields = ['Type', 'Size', 'Offset'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_OFFSETCLIPRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SELECTCLIPPATH:
    format = ['4b', '4b', '4b']
    name = "EMR_SELECTCLIPPATH"
    has_variable = True
    fields = ['Type', 'Size', 'RegionMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SELECTCLIPPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COMMENT:
    format = ['4b', '4b']
    name = "EMR_COMMENT"
    has_variable = True
    fields = ['Type', 'Size'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COMMENT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COMMENT_EMFPLUS:
    format = ['4b', '4b', '4b']
    name = "EMR_COMMENT_EMFPLUS"
    has_variable = True
    fields = ['Type', 'Size', 'CommentIdentifier'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COMMENT_EMFPLUS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COMMENT_EMFSPOOL:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_COMMENT_EMFSPOOL"
    has_variable = True
    fields = ['Type', 'Size', 'CommentIdentifier', 'EMFSpoolRecordIdentifier'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COMMENT_EMFSPOOL {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EOF:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_EOF"
    has_variable = True
    fields = ['Type', 'Size', 'nPalEntries', 'offPalEntries', 'SizeLast'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EOF {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ANGLEARC:
    format = ['4b', '4b', '8b', '4b', '4b', '4b']
    name = "EMR_ANGLEARC"
    has_variable = False
    fields = ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ANGLEARC {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ARC:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_ARC"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ARC {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ARCTO:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_ARCTO"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ARCTO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CHORD:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_CHORD"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CHORD {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ELLIPSE:
    format = ['4b', '4b', '16b']
    name = "EMR_ELLIPSE"
    has_variable = False
    fields = ['Type', 'Size', 'Box'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ELLIPSE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTFLOODFILL:
    format = ['4b', '4b', '8b', '4b', '4b']
    name = "EMR_EXTFLOODFILL"
    has_variable = False
    fields = ['Type', 'Size', 'Start', 'Color', 'FloodFillMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTFLOODFILL {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTTEXTOUTA:
    format = ['4b', '4b', '16b', '4b', '4b', '4b']
    name = "EMR_EXTTEXTOUTA"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTTEXTOUTA {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTTEXTOUTW:
    format = ['4b', '4b', '16b', '4b', '4b', '4b']
    name = "EMR_EXTTEXTOUTW"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTTEXTOUTW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FILLPATH:
    format = ['4b', '4b', '16b']
    name = "EMR_FILLPATH"
    has_variable = False
    fields = ['Type', 'Size', 'Bounds'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FILLPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FILLRGN:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_FILLRGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FILLRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FRAMERGN:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
    name = "EMR_FRAMERGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FRAMERGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_GRADIENTFILL:
    format = ['4b', '4b', '16b', '4b', '4b', '4b']
    name = "EMR_GRADIENTFILL"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_GRADIENTFILL {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_LINETO:
    format = ['4b', '4b', '8b']
    name = "EMR_LINETO"
    has_variable = False
    fields = ['Type', 'Size', 'Point'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_LINETO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PAINTRGN:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_PAINTRGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PAINTRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PIE:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_PIE"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PIE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIER:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIER"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIER {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIER16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIER16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIER16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIERTO:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIERTO"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIERTO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIERTO16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIERTO16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIERTO16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYDRAW:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYDRAW"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYDRAW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYDRAW16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYDRAW16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYDRAW16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYGON:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYGON"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYGON {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYGON16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYGON16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYGON16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINE:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINE"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINE16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINE16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINE16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINETO:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINETO"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINETO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINETO16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINETO16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINETO16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYGON:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYGON"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYGON {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYGON16:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYGON16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYGON16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYLINE:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYLINE"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYLINE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYLINE16:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYLINE16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYLINE16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYTEXTOUTA:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
    name = "EMR_POLYTEXTOUTA"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYTEXTOUTA {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYTEXTOUTW:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
    name = "EMR_POLYTEXTOUTW"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYTEXTOUTW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_RECTANGLE:
    format = ['4b', '4b', '16b']
    name = "EMR_RECTANGLE"
    has_variable = False
    fields = ['Type', 'Size', 'Box'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_RECTANGLE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ROUNDRECT:
    format = ['4b', '4b', '16b', '8b']
    name = "EMR_ROUNDRECT"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Corner'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ROUNDRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETPIXELV:
    format = ['4b', '4b', '8b', '4b']
    name = "EMR_SETPIXELV"
    has_variable = False
    fields = ['Type', 'Size', 'Pixel', 'Color'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETPIXELV {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SMALLTEXTOUT:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SMALLTEXTOUT"
    has_variable = True
    fields = ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SMALLTEXTOUT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STROKEANDFILLPATH:
    format = ['4b', '4b', '16b']
    name = "EMR_STROKEANDFILLPATH"
    has_variable = False
    fields = ['Type', 'Size', 'Bounds'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STROKEANDFILLPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STROKEPATH:
    format = ['4b', '4b', '16b']
    name = "EMR_STROKEPATH"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STROKEPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_DRAWESCAPE:
    format = ['4b', '4b', '4b']
    name = "EMR_DRAWESCAPE"
    has_variable = True
    fields = ['Type', 'Size', 'cjIn'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_DRAWESCAPE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTESCAPE:
    format = ['4b', '4b', '4b']
    name = "EMR_EXTESCAPE"
    has_variable = True
    fields = ['Type', 'Size', 'cjIn'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTESCAPE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_NAMEDESCAPE:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_NAMEDESCAPE"
    has_variable = True
    fields = ['Type', 'Size', 'cjDriver', 'cjIn'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_NAMEDESCAPE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEBRUSHINDIRECT:
    format = ['4b', '4b', '4b', '12b']
    name = "EMR_CREATEBRUSHINDIRECT"
    has_variable = False
    fields = ['Type', 'Size', 'ihBrush', 'LogBrush'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEBRUSHINDIRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATECOLORSPACE:
    format = ['4b', '4b', '4b']
    name = "EMR_CREATECOLORSPACE"
    has_variable = True
    fields = ['Type', 'Size', 'ihCS'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATECOLORSPACE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATECOLORSPACEW:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_CREATECOLORSPACEW"
    has_variable = True
    fields = ['Type', 'Size', 'ihCS', 'dwFlags', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATECOLORSPACEW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEDIBPATTERNBRUSHPT:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_CREATEDIBPATTERNBRUSHPT"
    has_variable = True
    fields = ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEDIBPATTERNBRUSHPT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEMONOBRUSH:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_CREATEMONOBRUSH"
    has_variable = True
    fields = ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEMONOBRUSH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEPALETTE:
    format = ['4b', '4b', '4b']
    name = "EMR_CREATEPALETTE"
    has_variable = True
    fields = ['Type', 'Size', 'ihPal'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEPEN:
    format = ['4b', '4b', '4b', '16b']
    name = "EMR_CREATEPEN"
    has_variable = False
    fields = ['Type', 'Size', 'ihPen', 'LogPen'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEPEN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTCREATEFONTINDIRECTW:
    format = ['4b', '4b', '4b']
    name = "EMR_EXTCREATEFONTINDIRECTW"
    has_variable = True
    fields = ['Type', 'Size', 'ihFonts'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTCREATEFONTINDIRECTW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTCREATEPEN:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_EXTCREATEPEN"
    has_variable = True
    fields = ['Type', 'Size', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTCREATEPEN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COLORCORRECTPALETTE:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_COLORCORRECTPALETTE"
    has_variable = False
    fields = ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COLORCORRECTPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_DELETECOLORSPACE:
    format = ['4b', '4b', '4b']
    name = "EMR_DELETECOLORSPACE"
    has_variable = False
    fields = ['Type', 'Size', 'ihCS'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_DELETECOLORSPACE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_DELETEOBJECT:
    format = ['4b', '4b', '4b']
    name = "EMR_DELETEOBJECT"
    has_variable = False
    fields = ['Type', 'Size', 'ihObject'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_DELETEOBJECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_RESIZEPALETTE:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_RESIZEPALETTE"
    has_variable = False
    fields = ['Type', 'Size', 'ihPal', 'NumberOfEntries'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_RESIZEPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SELECTOBJECT:
    format = ['4b', '4b', '4b']
    name = "EMR_SELECTOBJECT"
    has_variable = False
    fields = ['Type', 'Size', 'ihObject'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SELECTOBJECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SELECTPALETTE:
    format = ['4b', '4b', '4b']
    name = "EMR_SELECTPALETTE"
    has_variable = False
    fields = ['Type', 'Size', 'ihPal'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SELECTPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETCOLORSPACE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETCOLORSPACE"
    has_variable = False
    fields = ['Type', 'Size', 'ihCS'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETCOLORSPACE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETPALETTEENTRIES:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETPALETTEENTRIES"
    has_variable = True
    fields = ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETPALETTEENTRIES {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_GLSBOUNDEDRECORD:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_GLSBOUNDEDRECORD"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_GLSBOUNDEDRECORD {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_GLSRECORD:
    format = ['4b', '4b', '4b']
    name = "EMR_GLSRECORD"
    has_variable = True
    fields = ['Type', 'Size', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_GLSRECORD {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COLORMATCHTOTARGETW:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_COLORMATCHTOTARGETW"
    has_variable = True
    fields = ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COLORMATCHTOTARGETW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FORCEUFIMAPPING:
    format = ['4b', '4b', '8b']
    name = "EMR_FORCEUFIMAPPING"
    has_variable = False
    fields = ['Type', 'Size', 'ufi'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FORCEUFIMAPPING {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_INVERTRGN:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_INVERTRGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_INVERTRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_MOVETOEX:
    format = ['4b', '4b', '8b']
    name = "EMR_MOVETOEX"
    has_variable = False
    fields = ['Type', 'Size', 'Offset'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_MOVETOEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PIXELFORMAT:
    format = ['4b', '4b', '40b']
    name = "EMR_PIXELFORMAT"
    has_variable = False
    fields = ['Type', 'Size', 'pfd'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PIXELFORMAT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_RESTOREDC:
    format = ['4b', '4b', '4b']
    name = "EMR_RESTOREDC"
    has_variable = False
    fields = ['Type', 'Size', 'SavedDC'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_RESTOREDC {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SCALEVIEWPORTEXTEX:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SCALEVIEWPORTEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SCALEVIEWPORTEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SCALEWINDOWEXTEX:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SCALEWINDOWEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SCALEWINDOWEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETARCDIRECTION:
    format = ['4b', '4b', '4b']
    name = "EMR_SETARCDIRECTION"
    has_variable = False
    fields = ['Type', 'Size', 'ArcDirection'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETARCDIRECTION {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETBKCOLOR:
    format = ['4b', '4b', '4b']
    name = "EMR_SETBKCOLOR"
    has_variable = False
    fields = ['Type', 'Size', 'Color'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETBKCOLOR {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETBKMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETBKMODE"
    has_variable = False
    fields = ['Type', 'Size', 'BackgroundMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETBKMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETBRUSHORGEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETBRUSHORGEX"
    has_variable = False
    fields = ['Type', 'Size', 'Origin'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETBRUSHORGEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETCOLORADJUSTMENT:
    format = ['4b', '4b', '24b']
    name = "EMR_SETCOLORADJUSTMENT"
    has_variable = False
    fields = ['Type', 'Size', 'ColorAdjustment'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETCOLORADJUSTMENT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETICMMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETICMMODE"
    has_variable = False
    fields = ['Type', 'Size', 'ICMMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETICMMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETICMPROFILEA:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETICMPROFILEA"
    has_variable = True
    fields = ['Type', 'Size', 'dwFlags', 'cbName', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETICMPROFILEA {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETICMPROFILEW:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETICMPROFILEW"
    has_variable = True
    fields = ['Type', 'Size', 'dwFlags', 'cbName', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETICMPROFILEW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETLAYOUT:
    format = ['4b', '4b', '4b']
    name = "EMR_SETLAYOUT"
    has_variable = False
    fields = ['Type', 'Size', 'LayoutMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETLAYOUT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETLINKEDUFIS:
    format = ['4b', '4b', '4b', '8b']
    name = "EMR_SETLINKEDUFIS"
    has_variable = True
    fields = ['Type', 'Size', 'uNumLinkedUFI', 'Reserved'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETLINKEDUFIS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETMAPMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETMAPMODE"
    has_variable = False
    fields = ['Type', 'Size', 'MapMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETMAPMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETMAPPERFLAGS:
    format = ['4b', '4b', '4b']
    name = "EMR_SETMAPPERFLAGS"
    has_variable = False
    fields = ['Type', 'Size', 'Flags'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETMAPPERFLAGS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETMITERLIMIT:
    format = ['4b', '4b', '4b']
    name = "EMR_SETMITERLIMIT"
    has_variable = False
    fields = ['Type', 'Size', 'MiterLimit'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETMITERLIMIT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETPOLYFILLMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETPOLYFILLMODE"
    has_variable = False
    fields = ['Type', 'Size', 'PolygonFillMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETPOLYFILLMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETROP2:
    format = ['4b', '4b', '4b']
    name = "EMR_SETROP2"
    has_variable = False
    fields = ['Type', 'Size', 'ROP2Mode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETROP2 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETSTRETCHBLTMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETSTRETCHBLTMODE"
    has_variable = False
    fields = ['Type', 'Size', 'StretchMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETSTRETCHBLTMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETTEXTALIGN:
    format = ['4b', '4b', '4b']
    name = "EMR_SETTEXTALIGN"
    has_variable = False
    fields = ['Type', 'Size', 'TextAlignmentMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETTEXTALIGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETTEXTCOLOR:
    format = ['4b', '4b', '4b']
    name = "EMR_SETTEXTCOLOR"
    has_variable = False
    fields = ['Type', 'Size', 'Color'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETTEXTCOLOR {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETTEXTJUSTIFICATION:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_SETTEXTJUSTIFICATION"
    has_variable = False
    fields = ['Type', 'Size', 'nBreakExtra', 'nBreakCount'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETTEXTJUSTIFICATION {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETVIEWPORTEXTEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETVIEWPORTEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'Extent'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETVIEWPORTEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETVIEWPORTORGEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETVIEWPORTORGEX"
    has_variable = False
    fields = ['Type', 'Size', 'Origin'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETVIEWPORTORGEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETWINDOWEXTEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETWINDOWEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'Extent'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETWINDOWEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETWINDOWORGEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETWINDOWORGEX"
    has_variable = False
    fields = ['Type', 'Size', 'Origin'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETWINDOWORGEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_MODIFYWORLDTRANSFORM:
    format = ['4b', '4b', '24b', '4b']
    name = "EMR_MODIFYWORLDTRANSFORM"
    has_variable = False
    fields = ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_MODIFYWORLDTRANSFORM {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETWORLDTRANSFORM:
    format = ['4b', '4b', '24b']
    name = "EMR_SETWORLDTRANSFORM"
    has_variable = False
    fields = ['Type', 'Size', 'Xform'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETWORLDTRANSFORM {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes





