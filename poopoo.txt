Here is a field: Type
Line index: 3623
Here is a field: Bounds
Line index: 3625
Here is a field: xDest
Line index: 3629
Here is a field: yDest
Line index: 3631
Here is a field: cxDest
Line index: 3633
Here is a field: cyDest
Line index: 3635
Here is a field: BLENDFUNCTION
Line index: 3637
Here is a field: xSrc
Line index: 3674
Here is a field: ySrc
Line index: 3676
Here is a field: XformSrc
Line index: 3678
Here is a field: BkColorSrc
Line index: 3679
Here is a field: UsageSrc
Line index: 3681
Here is a field: offBmiSrc
Line index: 3683
Here is a field: cbBmiSrc
Line index: 3685
Here is a field: offBitsSrc
Line index: 3687
Here is a field: cbBitsSrc
Line index: 3689
Here is a field: cxSrc
Line index: 3690
Here is a field: cySrc
Line index: 3692
Bullshit before...
Name: EMR_ALPHABLEND
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Bullshit after...
Name: EMR_ALPHABLEND
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Here is a field: Type
Line index: 3809
Here is a field: Bounds
Line index: 3811
Here is a field: xDest
Line index: 3815
Here is a field: yDest
Line index: 3817
Here is a field: cxDest
Line index: 3819
Here is a field: cyDest
Line index: 3821
Here is a field: BitBltRasterOperation
Line index: 3823
Here is a field: xSrc
Line index: 3827
Here is a field: ySrc
Line index: 3829
Here is a field: XformSrc
Line index: 3831
Here is a field: BkColorSrc
Line index: 3832
Here is a field: UsageSrc
Line index: 3834
Here is a field: offBmiSrc
Line index: 3836
Here is a field: cbBmiSrc
Line index: 3838
Here is a field: offBitsSrc
Line index: 3840
Here is a field: cbBitsSrc
Line index: 3842
Bullshit before...
Name: EMR_BITBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Bullshit after...
Name: EMR_BITBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc']
Here is a field: Type
Line index: 3925
Here is a field: Bounds
Line index: 3927
Here is a field: xDest
Line index: 3931
Here is a field: yDest
Line index: 3933
Here is a field: cxDest
Line index: 3935
Here is a field: cyDest
Line index: 3936
Here is a field: ROP4
Line index: 3937
Here is a field: Reserved
Line index: 3948
Here is a field: xSrc
Line index: 3956
Here is a field: ySrc
Line index: 3958
Here is a field: XformSrc
Line index: 3960
Here is a field: BkColorSrc
Line index: 3961
Here is a field: UsageSrc
Line index: 3963
Here is a field: offBmiSrc
Line index: 3970
Here is a field: cbBmiSrc
Line index: 3972
Here is a field: offBitsSrc
Line index: 3974
Here is a field: cbBitsSrc
Line index: 3976
Here is a field: xMask
Line index: 3977
Here is a field: yMask
Line index: 3979
Here is a field: UsageMask
Line index: 3981
Here is a field: offBmiMask
Line index: 3983
Here is a field: cbBmiMask
Line index: 3985
Here is a field: offBitsMask
Line index: 3987
Here is a field: cbBitsMask
Line index: 3989
Bullshit before...
Name: EMR_MASKBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '2b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Bullshit after...
Name: EMR_MASKBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '2b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Here is a field: Type
Line index: 4086
Here is a field: Bounds
Line index: 4088
Here is a field: aptlDest
Line index: 4092
Here is a field: xSrc
Line index: 4098
Here is a field: ySrc
Line index: 4100
Here is a field: cxSrc
Line index: 4102
Here is a field: cySrc
Line index: 4103
Here is a field: XformSrc
Line index: 4104
Here is a field: BkColorSrc
Line index: 4105
Here is a field: UsageSrc
Line index: 4107
Here is a field: offBmiSrc
Line index: 4109
Here is a field: cbBmiSrc
Line index: 4111
Here is a field: offBitsSrc
Line index: 4113
Here is a field: cbBitsSrc
Line index: 4115
Here is a field: xMask
Line index: 4116
Here is a field: yMask
Line index: 4118
Here is a field: UsageMask
Line index: 4120
Here is a field: offBmiMask
Line index: 4127
Here is a field: cbBmiMask
Line index: 4129
Here is a field: offBitsMask
Line index: 4131
Here is a field: cbBitsMask
Line index: 4133
Bullshit before...
Name: EMR_PLGBLT
Here is the struct format: ['4b', '16b', '24b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields before: ['Type', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Fields after: ['Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Bullshit after...
Name: EMR_PLGBLT
Here is the struct format: ['4b', '4b', '16b', '24b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask']
Here is a field: Type
Line index: 4213
Here is a field: Bounds
Line index: 4215
Here is a field: xDest
Line index: 4219
Here is a field: yDest
Line index: 4221
Here is a field: xSrc
Line index: 4223
Here is a field: ySrc
Line index: 4225
Here is a field: cxSrc
Line index: 4227
Here is a field: cySrc
Line index: 4228
Here is a field: offBmiSrc
Line index: 4229
Here is a field: cbBmiSrc
Line index: 4231
Here is a field: offBitsSrc
Line index: 4233
Here is a field: cbBitsSrc
Line index: 4235
Here is a field: UsageSrc
Line index: 4236
Here is a field: iStartScan
Line index: 4238
Here is a field: cScans
Line index: 4239
Bullshit before...
Name: EMR_SETDIBITSTODEVICE
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Fields after: ['Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Bullshit after...
Name: EMR_SETDIBITSTODEVICE
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans']
Here is a field: Type
Line index: 4312
Here is a field: Bounds
Line index: 4314
Here is a field: xDest
Line index: 4318
Here is a field: yDest
Line index: 4325
Here is a field: cxDest
Line index: 4327
Here is a field: cyDest
Line index: 4328
Here is a field: BitBltRasterOperation
Line index: 4329
Here is a field: xSrc
Line index: 4333
Here is a field: ySrc
Line index: 4335
Here is a field: XformSrc
Line index: 4337
Here is a field: BkColorSrc
Line index: 4338
Here is a field: UsageSrc
Line index: 4340
Here is a field: offBmiSrc
Line index: 4342
Here is a field: cbBmiSrc
Line index: 4344
Here is a field: offBitsSrc
Line index: 4346
Here is a field: cbBitsSrc
Line index: 4348
Here is a field: cxSrc
Line index: 4349
Here is a field: cySrc
Line index: 4350
Bullshit before...
Name: EMR_STRETCHBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Bullshit after...
Name: EMR_STRETCHBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Here is a field: Type
Line index: 4418
Here is a field: Bounds
Line index: 4420
Here is a field: xDest
Line index: 4424
Here is a field: yDest
Line index: 4426
Here is a field: xSrc
Line index: 4428
Here is a field: ySrc
Line index: 4430
Here is a field: cxSrc
Line index: 4432
Here is a field: cySrc
Line index: 4433
Here is a field: offBmiSrc
Line index: 4434
Here is a field: cbBmiSrc
Line index: 4436
Here is a field: offBitsSrc
Line index: 4438
Here is a field: cbBitsSrc
Line index: 4440
Here is a field: UsageSrc
Line index: 4446
Here is a field: BitBltRasterOperation
Line index: 4448
Here is a field: cxDest
Line index: 4452
Here is a field: cyDest
Line index: 4453
Bullshit before...
Name: EMR_STRETCHDIBITS
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Fields after: ['Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Bullshit after...
Name: EMR_STRETCHDIBITS
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest']
Here is a field: Type
Line index: 4531
Here is a field: Bounds
Line index: 4533
Here is a field: xDest
Line index: 4537
Here is a field: yDest
Line index: 4539
Here is a field: cxDest
Line index: 4541
Here is a field: cyDest
Line index: 4542
Here is a field: TransparentColor
Line index: 4543
Here is a field: xSrc
Line index: 4545
Here is a field: ySrc
Line index: 4547
Here is a field: XformSrc
Line index: 4549
Here is a field: BkColorSrc
Line index: 4550
Here is a field: UsageSrc
Line index: 4551
Here is a field: offBmiSrc
Line index: 4553
Here is a field: cbBmiSrc
Line index: 4555
Here is a field: offBitsSrc
Line index: 4557
Here is a field: cbBitsSrc
Line index: 4564
Here is a field: cxSrc
Line index: 4565
Here is a field: cySrc
Line index: 4566
Bullshit before...
Name: EMR_TRANSPARENTBLT
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields before: ['Type', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Fields after: ['Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Bullshit after...
Name: EMR_TRANSPARENTBLT
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc']
Here is a field: Type
Line index: 4684
Here is a field: Clip
Line index: 4686
Bullshit before...
Name: EMR_EXCLUDECLIPRECT
Here is the struct format: ['4b', '16b']
Here is the fields: ['Type', 'Clip']
Fields before: ['Type', 'Clip']
Fields after: ['Clip']
Bullshit after...
Name: EMR_EXCLUDECLIPRECT
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Clip']
Here is a field: Type
Line index: 4713
Here is a field: RgnDataSize
Line index: 4715
Here is a field: RegionMode
Line index: 4716
Bullshit before...
Name: EMR_EXTSELECTCLIPRGN
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'RgnDataSize', 'RegionMode']
Fields before: ['Type', 'RgnDataSize', 'RegionMode']
Fields after: ['RgnDataSize', 'RegionMode']
Bullshit after...
Name: EMR_EXTSELECTCLIPRGN
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'RgnDataSize', 'RegionMode']
Here is a field: Type
Line index: 4744
Here is a field: Clip
Line index: 4746
Bullshit before...
Name: EMR_INTERSECTCLIPRECT
Here is the struct format: ['4b', '16b']
Here is the fields: ['Type', 'Clip']
Fields before: ['Type', 'Clip']
Fields after: ['Clip']
Bullshit after...
Name: EMR_INTERSECTCLIPRECT
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Clip']
Here is a field: Type
Line index: 4765
Here is a field: Offset
Line index: 4767
Bullshit before...
Name: EMR_OFFSETCLIPRGN
Here is the struct format: ['4b', '8b']
Here is the fields: ['Type', 'Offset']
Fields before: ['Type', 'Offset']
Fields after: ['Offset']
Bullshit after...
Name: EMR_OFFSETCLIPRGN
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Offset']
Here is a field: Type
Line index: 4789
Here is a field: RegionMode
Line index: 4791
Bullshit before...
Name: EMR_SELECTCLIPPATH
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'RegionMode']
Fields before: ['Type', 'RegionMode']
Fields after: ['RegionMode']
Bullshit after...
Name: EMR_SELECTCLIPPATH
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'RegionMode']
Bullshit before...
Name: EMR_COMMENT
Here is the struct format: []
Here is the fields: []
Fields before: []
Fields after: []
Bullshit after...
Name: EMR_COMMENT
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'Size']
Here is a field: CommentIdentifier
Line index: 4899
Bullshit before...
Name: EMR_COMMENT_EMFPLUS
Here is the struct format: ['4b']
Here is the fields: ['CommentIdentifier']
Fields before: ['CommentIdentifier']
Fields after: ['CommentIdentifier']
Bullshit after...
Name: EMR_COMMENT_EMFPLUS
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'CommentIdentifier']
Here is a field: CommentIdentifier
Line index: 4927
Here is a field: EMFSpoolRecordIdentifier
Line index: 4930
Not in record.
Previous record name: EMR_COMMENT_EMFSPOOL
Bullshit before...
Name: EMR_COMMENT_EMFSPOOL
Here is the struct format: ['4b', '4b']
Here is the fields: ['CommentIdentifier', 'EMFSpoolRecordIdentifier']
Fields before: ['CommentIdentifier', 'EMFSpoolRecordIdentifier']
Fields after: ['CommentIdentifier', 'EMFSpoolRecordIdentifier']
Bullshit after...
Name: EMR_COMMENT_EMFSPOOL
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'CommentIdentifier', 'EMFSpoolRecordIdentifier']
Here is a field: Type
Line index: 5205
Here is a field: nPalEntries
Line index: 5207
Here is a field: offPalEntries
Line index: 5208
Here is a field: SizeLast
Line index: 5233
Not in record.
Previous record name: EMR_EOF
Bullshit before...
Name: EMR_EOF
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'nPalEntries', 'offPalEntries', 'SizeLast']
Fields before: ['Type', 'nPalEntries', 'offPalEntries', 'SizeLast']
Fields after: ['nPalEntries', 'offPalEntries', 'SizeLast']
Bullshit after...
Name: EMR_EOF
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'nPalEntries', 'offPalEntries', 'SizeLast']
Here is a field: Type
Line index: 5708
Here is a field: Size
Line index: 5710
Here is a field: Center
Line index: 5711
Here is a field: Radius
Line index: 5713
Here is a field: StartAngle
Line index: 5719
Here is a field: SweepAngle
Line index: 5720
Bullshit before...
Name: EMR_ANGLEARC
Here is the struct format: ['4b', '4b', '8b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle']
Fields before: ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle']
Fields after: ['Center', 'Radius', 'StartAngle', 'SweepAngle']
Bullshit after...
Name: EMR_ANGLEARC
Here is the struct format: ['4b', '4b', '8b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle']
Here is a field: Type
Line index: 5747
Here is a field: Size
Line index: 5749
Here is a field: Box
Line index: 5750
Here is a field: Start
Line index: 5751
Here is a field: End
Line index: 5753
Bullshit before...
Name: EMR_ARC
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_ARC
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Here is a field: Type
Line index: 5781
Here is a field: Size
Line index: 5783
Here is a field: Box
Line index: 5784
Here is a field: Start
Line index: 5785
Here is a field: End
Line index: 5787
Bullshit before...
Name: EMR_ARCTO
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_ARCTO
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Here is a field: Type
Line index: 5816
Here is a field: Size
Line index: 5818
Here is a field: Box
Line index: 5819
Here is a field: Start
Line index: 5820
Here is a field: End
Line index: 5822
Bullshit before...
Name: EMR_CHORD
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_CHORD
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Here is a field: Type
Line index: 5853
Here is a field: Size
Line index: 5855
Here is a field: Box
Line index: 5856
Bullshit before...
Name: EMR_ELLIPSE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Fields before: ['Type', 'Size', 'Box']
Fields after: ['Box']
Bullshit after...
Name: EMR_ELLIPSE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Here is a field: Type
Line index: 5873
Here is a field: Size
Line index: 5875
Here is a field: Start
Line index: 5876
Here is a field: Color
Line index: 5878
Here is a field: FloodFillMode
Line index: 5885
Bullshit before...
Name: EMR_EXTFLOODFILL
Here is the struct format: ['4b', '4b', '8b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Start', 'Color', 'FloodFillMode']
Fields before: ['Type', 'Size', 'Start', 'Color', 'FloodFillMode']
Fields after: ['Start', 'Color', 'FloodFillMode']
Bullshit after...
Name: EMR_EXTFLOODFILL
Here is the struct format: ['4b', '4b', '8b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Start', 'Color', 'FloodFillMode']
Here is a field: Type
Line index: 5910
Here is a field: Bounds
Line index: 5912
Here is a field: iGraphicsMode
Line index: 5914
Here is a field: exScale
Line index: 5916
Here is a field: eyScale
Line index: 5919
Bullshit before...
Name: EMR_EXTTEXTOUTA
Here is the struct format: ['4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Bullshit after...
Name: EMR_EXTTEXTOUTA
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Here is a field: Type
Line index: 5956
Here is a field: Bounds
Line index: 5958
Here is a field: iGraphicsMode
Line index: 5960
Here is a field: exScale
Line index: 5962
Here is a field: eyScale
Line index: 5970
Bullshit before...
Name: EMR_EXTTEXTOUTW
Here is the struct format: ['4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Bullshit after...
Name: EMR_EXTTEXTOUTW
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale']
Here is a field: Type
Line index: 5995
Here is a field: Size
Line index: 5997
Here is a field: Bounds
Line index: 5998
Bullshit before...
Name: EMR_FILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Fields before: ['Type', 'Size', 'Bounds']
Fields after: ['Bounds']
Bullshit after...
Name: EMR_FILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Here is a field: Type
Line index: 6027
Here is a field: Size
Line index: 6029
Here is a field: Bounds
Line index: 6030
Here is a field: RgnDataSize
Line index: 6033
Here is a field: ihBrush
Line index: 6034
Bullshit before...
Name: EMR_FILLRGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush']
Fields after: ['Bounds', 'RgnDataSize', 'ihBrush']
Bullshit after...
Name: EMR_FILLRGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush']
Here is a field: Type
Line index: 6068
Here is a field: Size
Line index: 6070
Here is a field: Bounds
Line index: 6071
Here is a field: RgnDataSize
Line index: 6074
Here is a field: ihBrush
Line index: 6075
Here is a field: Width
Line index: 6077
Here is a field: Height
Line index: 6079
Bullshit before...
Name: EMR_FRAMERGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Fields after: ['Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Bullshit after...
Name: EMR_FRAMERGN
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height']
Here is a field: Type
Line index: 6110
Here is a field: Size
Line index: 6112
Here is a field: Bounds
Line index: 6113
Here is a field: nVer
Line index: 6114
Here is a field: nTri
Line index: 6115
Here is a field: ulMode
Line index: 6116
Bullshit before...
Name: EMR_GRADIENTFILL
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode']
Fields before: ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode']
Fields after: ['Bounds', 'nVer', 'nTri', 'ulMode']
Bullshit after...
Name: EMR_GRADIENTFILL
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode']
Here is a field: Type
Line index: 6173
Here is a field: Size
Line index: 6175
Here is a field: Point
Line index: 6176
Bullshit before...
Name: EMR_LINETO
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Point']
Fields before: ['Type', 'Size', 'Point']
Fields after: ['Point']
Bullshit after...
Name: EMR_LINETO
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Point']
Here is a field: Type
Line index: 6204
Here is a field: Size
Line index: 6206
Here is a field: Bounds
Line index: 6207
Here is a field: RgnDataSize
Line index: 6210
Bullshit before...
Name: EMR_PAINTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields after: ['Bounds', 'RgnDataSize']
Bullshit after...
Name: EMR_PAINTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Here is a field: Type
Line index: 6241
Here is a field: Size
Line index: 6243
Here is a field: Box
Line index: 6244
Here is a field: Start
Line index: 6245
Here is a field: End
Line index: 6247
Bullshit before...
Name: EMR_PIE
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Fields before: ['Type', 'Size', 'Box', 'Start', 'End']
Fields after: ['Box', 'Start', 'End']
Bullshit after...
Name: EMR_PIE
Here is the struct format: ['4b', '4b', '16b', '8b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Start', 'End']
Here is a field: Type
Line index: 6277
Here is a field: Size
Line index: 6279
Here is a field: Bounds
Line index: 6280
Here is a field: Count
Line index: 6282
Bullshit before...
Name: EMR_POLYBEZIER
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIER
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6324
Here is a field: Size
Line index: 6326
Here is a field: Bounds
Line index: 6327
Here is a field: Count
Line index: 6328
Bullshit before...
Name: EMR_POLYBEZIER16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIER16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6358
Here is a field: Size
Line index: 6360
Here is a field: Bounds
Line index: 6361
Here is a field: Count
Line index: 6363
Bullshit before...
Name: EMR_POLYBEZIERTO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIERTO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6400
Here is a field: Size
Line index: 6402
Here is a field: Bounds
Line index: 6403
Here is a field: Count
Line index: 6405
Bullshit before...
Name: EMR_POLYBEZIERTO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYBEZIERTO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6432
Here is a field: Size
Line index: 6439
Here is a field: Bounds
Line index: 6440
Here is a field: Count
Line index: 6442
Bullshit before...
Name: EMR_POLYDRAW
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYDRAW
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6468
Here is a field: Size
Line index: 6470
Here is a field: Bounds
Line index: 6471
Here is a field: Count
Line index: 6473
Bullshit before...
Name: EMR_POLYDRAW16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYDRAW16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6503
Here is a field: Size
Line index: 6505
Here is a field: Bounds
Line index: 6506
Here is a field: Count
Line index: 6508
Bullshit before...
Name: EMR_POLYGON
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYGON
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6546
Here is a field: Size
Line index: 6548
Here is a field: Bounds
Line index: 6549
Here is a field: Count
Line index: 6551
Bullshit before...
Name: EMR_POLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6579
Here is a field: Size
Line index: 6581
Here is a field: Bounds
Line index: 6582
Here is a field: Count
Line index: 6584
Bullshit before...
Name: EMR_POLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6618
Here is a field: Size
Line index: 6620
Here is a field: Bounds
Line index: 6621
Here is a field: Count
Line index: 6623
Bullshit before...
Name: EMR_POLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6651
Here is a field: Size
Line index: 6653
Here is a field: Bounds
Line index: 6654
Here is a field: Count
Line index: 6656
Bullshit before...
Name: EMR_POLYLINETO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINETO
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6692
Here is a field: Size
Line index: 6694
Here is a field: Bounds
Line index: 6695
Here is a field: Count
Line index: 6697
Bullshit before...
Name: EMR_POLYLINETO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'Count']
Fields after: ['Bounds', 'Count']
Bullshit after...
Name: EMR_POLYLINETO16
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'Count']
Here is a field: Type
Line index: 6731
Here is a field: Bounds
Line index: 6733
Here is a field: NumberOfPolygons
Line index: 6735
Here is a field: Count
Line index: 6736
Bullshit before...
Name: EMR_POLYPOLYGON
Here is the struct format: ['4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'NumberOfPolygons', 'Count']
Fields before: ['Type', 'Bounds', 'NumberOfPolygons', 'Count']
Fields after: ['Bounds', 'NumberOfPolygons', 'Count']
Bullshit after...
Name: EMR_POLYPOLYGON
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Here is a field: Type
Line index: 6780
Here is a field: Size
Line index: 6782
Here is a field: Bounds
Line index: 6783
Here is a field: NumberOfPolygons
Line index: 6785
Here is a field: Count
Line index: 6786
Bullshit before...
Name: EMR_POLYPOLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Fields after: ['Bounds', 'NumberOfPolygons', 'Count']
Bullshit after...
Name: EMR_POLYPOLYGON16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count']
Here is a field: Type
Line index: 6818
Here is a field: Size
Line index: 6820
Here is a field: Bounds
Line index: 6821
Here is a field: NumberOfPolylines
Line index: 6823
Here is a field: Count
Line index: 6825
Bullshit before...
Name: EMR_POLYPOLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields after: ['Bounds', 'NumberOfPolylines', 'Count']
Bullshit after...
Name: EMR_POLYPOLYLINE
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Here is a field: Type
Line index: 6866
Here is a field: Size
Line index: 6868
Here is a field: Bounds
Line index: 6869
Here is a field: NumberOfPolylines
Line index: 6871
Here is a field: Count
Line index: 6872
Bullshit before...
Name: EMR_POLYPOLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields before: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Fields after: ['Bounds', 'NumberOfPolylines', 'Count']
Bullshit after...
Name: EMR_POLYPOLYLINE16
Here is the struct format: ['4b', '4b', '16b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count']
Here is a field: Type
Line index: 6906
Here is a field: Bounds
Line index: 6908
Here is a field: iGraphicsMode
Line index: 6910
Here is a field: exScale
Line index: 6912
Here is a field: eyScale
Line index: 6914
Here is a field: cStrings
Line index: 6916
Bullshit before...
Name: EMR_POLYTEXTOUTA
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Bullshit after...
Name: EMR_POLYTEXTOUTA
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Here is a field: Type
Line index: 6954
Here is a field: Bounds
Line index: 6956
Here is a field: iGraphicsMode
Line index: 6958
Here is a field: exScale
Line index: 6960
Here is a field: eyScale
Line index: 6962
Here is a field: cStrings
Line index: 6964
Bullshit before...
Name: EMR_POLYTEXTOUTW
Here is the struct format: ['4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields before: ['Type', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Fields after: ['Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Bullshit after...
Name: EMR_POLYTEXTOUTW
Here is the struct format: ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings']
Here is a field: Type
Line index: 6994
Here is a field: Size
Line index: 6996
Here is a field: Box
Line index: 6997
Bullshit before...
Name: EMR_RECTANGLE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Fields before: ['Type', 'Size', 'Box']
Fields after: ['Box']
Bullshit after...
Name: EMR_RECTANGLE
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Box']
Here is a field: Type
Line index: 7025
Here is a field: Size
Line index: 7027
Here is a field: Box
Line index: 7028
Here is a field: Corner
Line index: 7029
Bullshit before...
Name: EMR_ROUNDRECT
Here is the struct format: ['4b', '4b', '16b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Corner']
Fields before: ['Type', 'Size', 'Box', 'Corner']
Fields after: ['Box', 'Corner']
Bullshit after...
Name: EMR_ROUNDRECT
Here is the struct format: ['4b', '4b', '16b', '8b']
Here is the fields: ['Type', 'Size', 'Box', 'Corner']
Here is a field: Type
Line index: 7046
Here is a field: Size
Line index: 7048
Here is a field: Pixel
Line index: 7049
Here is a field: Color
Line index: 7051
Bullshit before...
Name: EMR_SETPIXELV
Here is the struct format: ['4b', '4b', '8b', '4b']
Here is the fields: ['Type', 'Size', 'Pixel', 'Color']
Fields before: ['Type', 'Size', 'Pixel', 'Color']
Fields after: ['Pixel', 'Color']
Bullshit after...
Name: EMR_SETPIXELV
Here is the struct format: ['4b', '4b', '8b', '4b']
Here is the fields: ['Type', 'Size', 'Pixel', 'Color']
Here is a field: Type
Line index: 7082
Here is a field: Size
Line index: 7084
Here is a field: x
Line index: 7085
Here is a field: y
Line index: 7086
Here is a field: cChars
Line index: 7087
Here is a field: fuOptions
Line index: 7094
Here is a field: iGraphicsMode
Line index: 7097
Here is a field: exScale
Line index: 7099
Here is a field: eyScale
Line index: 7100
Bullshit before...
Name: EMR_SMALLTEXTOUT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Fields before: ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Fields after: ['x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Bullshit after...
Name: EMR_SMALLTEXTOUT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale']
Here is a field: Type
Line index: 7126
Here is a field: Size
Line index: 7128
Here is a field: Bounds
Line index: 7129
Bullshit before...
Name: EMR_STROKEANDFILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Fields before: ['Type', 'Size', 'Bounds']
Fields after: ['Bounds']
Bullshit after...
Name: EMR_STROKEANDFILLPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Here is a field: Type
Line index: 7152
Here is a field: Size
Line index: 7154
Here is a field: Bounds
Line index: 7155
Bullshit before...
Name: EMR_STROKEPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Fields before: ['Type', 'Size', 'Bounds']
Fields after: ['Bounds']
Bullshit after...
Name: EMR_STROKEPATH
Here is the struct format: ['4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'Bounds']
Here is a field: Type
Line index: 7235
Here is a field: cjIn
Line index: 7237
Bullshit before...
Name: EMR_DRAWESCAPE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'cjIn']
Fields before: ['Type', 'cjIn']
Fields after: ['cjIn']
Bullshit after...
Name: EMR_DRAWESCAPE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cjIn']
Here is a field: Type
Line index: 7257
Here is a field: cjIn
Line index: 7259
Bullshit before...
Name: EMR_EXTESCAPE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'cjIn']
Fields before: ['Type', 'cjIn']
Fields after: ['cjIn']
Bullshit after...
Name: EMR_EXTESCAPE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cjIn']
Here is a field: Type
Line index: 7286
Here is a field: cjDriver
Line index: 7288
Here is a field: cjIn
Line index: 7290
Bullshit before...
Name: EMR_NAMEDESCAPE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'cjDriver', 'cjIn']
Fields before: ['Type', 'cjDriver', 'cjIn']
Fields after: ['cjDriver', 'cjIn']
Bullshit after...
Name: EMR_NAMEDESCAPE
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cjDriver', 'cjIn']
Here is a field: Type
Line index: 7387
Here is a field: Size
Line index: 7389
Here is a field: ihBrush
Line index: 7391
Here is a field: LogBrush
Line index: 7394
Bullshit before...
Name: EMR_CREATEBRUSHINDIRECT
Here is the struct format: ['4b', '4b', '4b', '12b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'LogBrush']
Fields before: ['Type', 'Size', 'ihBrush', 'LogBrush']
Fields after: ['ihBrush', 'LogBrush']
Bullshit after...
Name: EMR_CREATEBRUSHINDIRECT
Here is the struct format: ['4b', '4b', '4b', '12b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'LogBrush']
Here is a field: Type
Line index: 7419
Here is a field: ihCS
Line index: 7421
Bullshit before...
Name: EMR_CREATECOLORSPACE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'ihCS']
Fields before: ['Type', 'ihCS']
Fields after: ['ihCS']
Bullshit after...
Name: EMR_CREATECOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Here is a field: Type
Line index: 7455
Here is a field: ihCS
Line index: 7457
Here is a field: dwFlags
Line index: 7462
Here is a field: cbData
Line index: 7472
Bullshit before...
Name: EMR_CREATECOLORSPACEW
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihCS', 'dwFlags', 'cbData']
Fields before: ['Type', 'ihCS', 'dwFlags', 'cbData']
Fields after: ['ihCS', 'dwFlags', 'cbData']
Bullshit after...
Name: EMR_CREATECOLORSPACEW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS', 'dwFlags', 'cbData']
Here is a field: Type
Line index: 7505
Here is a field: ihBrush
Line index: 7507
Here is a field: Usage
Line index: 7510
Here is a field: offBmi
Line index: 7512
Here is a field: cbBmi
Line index: 7514
Here is a field: offBits
Line index: 7515
Here is a field: cbBits
Line index: 7517
Bullshit before...
Name: EMR_CREATEDIBPATTERNBRUSHPT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields before: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields after: ['ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Bullshit after...
Name: EMR_CREATEDIBPATTERNBRUSHPT
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Here is a field: Type
Line index: 7568
Here is a field: ihBrush
Line index: 7570
Here is a field: Usage
Line index: 7573
Here is a field: offBmi
Line index: 7575
Here is a field: cbBmi
Line index: 7577
Here is a field: offBits
Line index: 7583
Here is a field: cbBits
Line index: 7585
Bullshit before...
Name: EMR_CREATEMONOBRUSH
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields before: ['Type', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields after: ['ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Bullshit after...
Name: EMR_CREATEMONOBRUSH
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Here is a field: Type
Line index: 7630
Here is a field: ihPal
Line index: 7632
Bullshit before...
Name: EMR_CREATEPALETTE
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'ihPal']
Fields before: ['Type', 'ihPal']
Fields after: ['ihPal']
Bullshit after...
Name: EMR_CREATEPALETTE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal']
Here is a field: Type
Line index: 7658
Here is a field: Size
Line index: 7660
Here is a field: ihPen
Line index: 7662
Here is a field: LogPen
Line index: 7665
Bullshit before...
Name: EMR_CREATEPEN
Here is the struct format: ['4b', '4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'ihPen', 'LogPen']
Fields before: ['Type', 'Size', 'ihPen', 'LogPen']
Fields after: ['ihPen', 'LogPen']
Bullshit after...
Name: EMR_CREATEPEN
Here is the struct format: ['4b', '4b', '4b', '16b']
Here is the fields: ['Type', 'Size', 'ihPen', 'LogPen']
Here is a field: Type
Line index: 7691
Here is a field: ihFonts
Line index: 7693
Bullshit before...
Name: EMR_EXTCREATEFONTINDIRECTW
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'ihFonts']
Fields before: ['Type', 'ihFonts']
Fields after: ['ihFonts']
Bullshit after...
Name: EMR_EXTCREATEFONTINDIRECTW
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihFonts']
Here is a field: Type
Line index: 7754
Here is a field: ihPen
Line index: 7761
Here is a field: offBmi
Line index: 7764
Here is a field: cbBmi
Line index: 7766
Here is a field: offBits
Line index: 7768
Here is a field: cbBits
Line index: 7770
Bullshit before...
Name: EMR_EXTCREATEPEN
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields before: ['Type', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Fields after: ['ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Bullshit after...
Name: EMR_EXTCREATEPEN
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits']
Here is a field: Type
Line index: 7887
Here is a field: Size
Line index: 7889
Here is a field: ihPalette
Line index: 7891
Here is a field: nFirstEntry
Line index: 7893
Here is a field: nPalEntries
Line index: 7899
Here is a field: nReserved
Line index: 7900
Bullshit before...
Name: EMR_COLORCORRECTPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Fields before: ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Fields after: ['ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Bullshit after...
Name: EMR_COLORCORRECTPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved']
Here is a field: Type
Line index: 7914
Here is a field: Size
Line index: 7916
Here is a field: ihCS
Line index: 7917
Bullshit before...
Name: EMR_DELETECOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Fields before: ['Type', 'Size', 'ihCS']
Fields after: ['ihCS']
Bullshit after...
Name: EMR_DELETECOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Here is a field: Type
Line index: 7938
Here is a field: Size
Line index: 7940
Here is a field: ihObject
Line index: 7946
Bullshit before...
Name: EMR_DELETEOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Fields before: ['Type', 'Size', 'ihObject']
Fields after: ['ihObject']
Bullshit after...
Name: EMR_DELETEOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Here is a field: Type
Line index: 7968
Here is a field: Size
Line index: 7970
Here is a field: ihPal
Line index: 7971
Here is a field: NumberOfEntries
Line index: 7973
Bullshit before...
Name: EMR_RESIZEPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'NumberOfEntries']
Fields before: ['Type', 'Size', 'ihPal', 'NumberOfEntries']
Fields after: ['ihPal', 'NumberOfEntries']
Bullshit after...
Name: EMR_RESIZEPALETTE
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'NumberOfEntries']
Here is a field: Type
Line index: 7995
Here is a field: Size
Line index: 7997
Here is a field: ihObject
Line index: 7998
Bullshit before...
Name: EMR_SELECTOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Fields before: ['Type', 'Size', 'ihObject']
Fields after: ['ihObject']
Bullshit after...
Name: EMR_SELECTOBJECT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihObject']
Here is a field: Type
Line index: 8017
Here is a field: Size
Line index: 8019
Here is a field: ihPal
Line index: 8021
Bullshit before...
Name: EMR_SELECTPALETTE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal']
Fields before: ['Type', 'Size', 'ihPal']
Fields after: ['ihPal']
Bullshit after...
Name: EMR_SELECTPALETTE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal']
Here is a field: Type
Line index: 8046
Here is a field: Size
Line index: 8048
Here is a field: ihCS
Line index: 8050
Bullshit before...
Name: EMR_SETCOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Fields before: ['Type', 'Size', 'ihCS']
Fields after: ['ihCS']
Bullshit after...
Name: EMR_SETCOLORSPACE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihCS']
Here is a field: Type
Line index: 8074
Here is a field: Size
Line index: 8076
Here is a field: ihPal
Line index: 8077
Here is a field: Start
Line index: 8079
Here is a field: NumberofEntries
Line index: 8080
Bullshit before...
Name: EMR_SETPALETTEENTRIES
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries']
Fields before: ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries']
Fields after: ['ihPal', 'Start', 'NumberofEntries']
Bullshit after...
Name: EMR_SETPALETTEENTRIES
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries']
Here is a field: Type
Line index: 8158
Here is a field: Bounds
Line index: 8160
Here is a field: cbData
Line index: 8162
Bullshit before...
Name: EMR_GLSBOUNDEDRECORD
Here is the struct format: ['4b', '16b', '4b']
Here is the fields: ['Type', 'Bounds', 'cbData']
Fields before: ['Type', 'Bounds', 'cbData']
Fields after: ['Bounds', 'cbData']
Bullshit after...
Name: EMR_GLSBOUNDEDRECORD
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'cbData']
Here is a field: Type
Line index: 8186
Here is a field: cbData
Line index: 8188
Bullshit before...
Name: EMR_GLSRECORD
Here is the struct format: ['4b', '4b']
Here is the fields: ['Type', 'cbData']
Fields before: ['Type', 'cbData']
Fields after: ['cbData']
Bullshit after...
Name: EMR_GLSRECORD
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'cbData']
Here is a field: Type
Line index: 8419
Here is a field: Size
Line index: 8421
Here is a field: dwAction
Line index: 8422
Here is a field: dwFlags
Line index: 8424
Here is a field: cbName
Line index: 8426
Here is a field: cbData
Line index: 8428
Bullshit before...
Name: EMR_COLORMATCHTOTARGETW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData']
Fields before: ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData']
Fields after: ['dwAction', 'dwFlags', 'cbName', 'cbData']
Bullshit after...
Name: EMR_COLORMATCHTOTARGETW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData']
Here is a field: Type
Line index: 8463
Here is a field: Size
Line index: 8465
Here is a field: ufi
Line index: 8466
Bullshit before...
Name: EMR_FORCEUFIMAPPING
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'ufi']
Fields before: ['Type', 'Size', 'ufi']
Fields after: ['ufi']
Bullshit after...
Name: EMR_FORCEUFIMAPPING
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'ufi']
Here is a field: Type
Line index: 8493
Here is a field: Size
Line index: 8495
Here is a field: Bounds
Line index: 8496
Here is a field: RgnDataSize
Line index: 8499
Bullshit before...
Name: EMR_INVERTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields before: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Fields after: ['Bounds', 'RgnDataSize']
Bullshit after...
Name: EMR_INVERTRGN
Here is the struct format: ['4b', '4b', '16b', '4b']
Here is the fields: ['Type', 'Size', 'Bounds', 'RgnDataSize']
Here is a field: Type
Line index: 8521
Here is a field: Size
Line index: 8523
Here is a field: Offset
Line index: 8524
Bullshit before...
Name: EMR_MOVETOEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Offset']
Fields before: ['Type', 'Size', 'Offset']
Fields after: ['Offset']
Bullshit after...
Name: EMR_MOVETOEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Offset']
Here is a field: Type
Line index: 8547
Here is a field: Size
Line index: 8549
Here is a field: pfd
Line index: 8550
Bullshit before...
Name: EMR_PIXELFORMAT
Here is the struct format: ['4b', '4b', '40b']
Here is the fields: ['Type', 'Size', 'pfd']
Fields before: ['Type', 'Size', 'pfd']
Fields after: ['pfd']
Bullshit after...
Name: EMR_PIXELFORMAT
Here is the struct format: ['4b', '4b', '40b']
Here is the fields: ['Type', 'Size', 'pfd']
Here is a field: Type
Line index: 8566
Here is a field: Size
Line index: 8568
Here is a field: SavedDC
Line index: 8570
Bullshit before...
Name: EMR_RESTOREDC
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'SavedDC']
Fields before: ['Type', 'Size', 'SavedDC']
Fields after: ['SavedDC']
Bullshit after...
Name: EMR_RESTOREDC
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'SavedDC']
Here is a field: Type
Line index: 8597
Here is a field: Size
Line index: 8599
Here is a field: xNum
Line index: 8600
Here is a field: xDenom
Line index: 8601
Here is a field: yNum
Line index: 8602
Here is a field: yDenom
Line index: 8603
Bullshit before...
Name: EMR_SCALEVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields before: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields after: ['xNum', 'xDenom', 'yNum', 'yDenom']
Bullshit after...
Name: EMR_SCALEVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Here is a field: Type
Line index: 8631
Here is a field: Size
Line index: 8633
Here is a field: xNum
Line index: 8634
Here is a field: xDenom
Line index: 8635
Here is a field: yNum
Line index: 8636
Here is a field: yDenom
Line index: 8637
Bullshit before...
Name: EMR_SCALEWINDOWEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields before: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Fields after: ['xNum', 'xDenom', 'yNum', 'yDenom']
Bullshit after...
Name: EMR_SCALEWINDOWEXTEX
Here is the struct format: ['4b', '4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom']
Here is a field: Type
Line index: 8658
Here is a field: Size
Line index: 8660
Here is a field: ArcDirection
Line index: 8667
Bullshit before...
Name: EMR_SETARCDIRECTION
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ArcDirection']
Fields before: ['Type', 'Size', 'ArcDirection']
Fields after: ['ArcDirection']
Bullshit after...
Name: EMR_SETARCDIRECTION
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ArcDirection']
Here is a field: Type
Line index: 8690
Here is a field: Size
Line index: 8692
Here is a field: Color
Line index: 8693
Bullshit before...
Name: EMR_SETBKCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Fields before: ['Type', 'Size', 'Color']
Fields after: ['Color']
Bullshit after...
Name: EMR_SETBKCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Here is a field: Type
Line index: 8714
Here is a field: Size
Line index: 8716
Here is a field: BackgroundMode
Line index: 8717
Bullshit before...
Name: EMR_SETBKMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'BackgroundMode']
Fields before: ['Type', 'Size', 'BackgroundMode']
Fields after: ['BackgroundMode']
Bullshit after...
Name: EMR_SETBKMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'BackgroundMode']
Here is a field: Type
Line index: 8733
Here is a field: Size
Line index: 8735
Here is a field: Origin
Line index: 8736
Bullshit before...
Name: EMR_SETBRUSHORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Fields before: ['Type', 'Size', 'Origin']
Fields after: ['Origin']
Bullshit after...
Name: EMR_SETBRUSHORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Here is a field: Type
Line index: 8760
Here is a field: Size
Line index: 8762
Here is a field: ColorAdjustment
Line index: 8764
Bullshit before...
Name: EMR_SETCOLORADJUSTMENT
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'ColorAdjustment']
Fields before: ['Type', 'Size', 'ColorAdjustment']
Fields after: ['ColorAdjustment']
Bullshit after...
Name: EMR_SETCOLORADJUSTMENT
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'ColorAdjustment']
Here is a field: Type
Line index: 8786
Here is a field: Size
Line index: 8788
Here is a field: ICMMode
Line index: 8790
Bullshit before...
Name: EMR_SETICMMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ICMMode']
Fields before: ['Type', 'Size', 'ICMMode']
Fields after: ['ICMMode']
Bullshit after...
Name: EMR_SETICMMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ICMMode']
Here is a field: Type
Line index: 8819
Here is a field: Size
Line index: 8821
Here is a field: dwFlags
Line index: 8822
Here is a field: cbName
Line index: 8823
Here is a field: cbData
Line index: 8825
Bullshit before...
Name: EMR_SETICMPROFILEA
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields before: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields after: ['dwFlags', 'cbName', 'cbData']
Bullshit after...
Name: EMR_SETICMPROFILEA
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Here is a field: Type
Line index: 8852
Here is a field: Size
Line index: 8854
Here is a field: dwFlags
Line index: 8855
Here is a field: cbName
Line index: 8856
Here is a field: cbData
Line index: 8858
Bullshit before...
Name: EMR_SETICMPROFILEW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields before: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Fields after: ['dwFlags', 'cbName', 'cbData']
Bullshit after...
Name: EMR_SETICMPROFILEW
Here is the struct format: ['4b', '4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'dwFlags', 'cbName', 'cbData']
Here is a field: Type
Line index: 8874
Here is a field: Size
Line index: 8876
Here is a field: LayoutMode
Line index: 8878
Bullshit before...
Name: EMR_SETLAYOUT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'LayoutMode']
Fields before: ['Type', 'Size', 'LayoutMode']
Fields after: ['LayoutMode']
Bullshit after...
Name: EMR_SETLAYOUT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'LayoutMode']
Here is a field: Type
Line index: 8915
Here is a field: Size
Line index: 8917
Here is a field: uNumLinkedUFI
Line index: 8918
Here is a field: Reserved
Line index: 8921
Bullshit before...
Name: EMR_SETLINKEDUFIS
Here is the struct format: ['4b', '4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'uNumLinkedUFI', 'Reserved']
Fields before: ['Type', 'Size', 'uNumLinkedUFI', 'Reserved']
Fields after: ['uNumLinkedUFI', 'Reserved']
Bullshit after...
Name: EMR_SETLINKEDUFIS
Here is the struct format: ['4b', '4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'uNumLinkedUFI', 'Reserved']
Here is a field: Type
Line index: 8937
Here is a field: Size
Line index: 8939
Here is a field: MapMode
Line index: 8945
Bullshit before...
Name: EMR_SETMAPMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MapMode']
Fields before: ['Type', 'Size', 'MapMode']
Fields after: ['MapMode']
Bullshit after...
Name: EMR_SETMAPMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MapMode']
Here is a field: Type
Line index: 8965
Here is a field: Size
Line index: 8967
Here is a field: Flags
Line index: 8969
Bullshit before...
Name: EMR_SETMAPPERFLAGS
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Flags']
Fields before: ['Type', 'Size', 'Flags']
Fields after: ['Flags']
Bullshit after...
Name: EMR_SETMAPPERFLAGS
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Flags']
Here is a field: Type
Line index: 8991
Here is a field: Size
Line index: 8993
Here is a field: MiterLimit
Line index: 8994
Bullshit before...
Name: EMR_SETMITERLIMIT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MiterLimit']
Fields before: ['Type', 'Size', 'MiterLimit']
Fields after: ['MiterLimit']
Bullshit after...
Name: EMR_SETMITERLIMIT
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'MiterLimit']
Here is a field: Type
Line index: 9008
Here is a field: Size
Line index: 9010
Here is a field: PolygonFillMode
Line index: 9011
Bullshit before...
Name: EMR_SETPOLYFILLMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'PolygonFillMode']
Fields before: ['Type', 'Size', 'PolygonFillMode']
Fields after: ['PolygonFillMode']
Bullshit after...
Name: EMR_SETPOLYFILLMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'PolygonFillMode']
Here is a field: Type
Line index: 9041
Here is a field: Size
Line index: 9043
Here is a field: ROP2Mode
Line index: 9044
Bullshit before...
Name: EMR_SETROP2
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ROP2Mode']
Fields before: ['Type', 'Size', 'ROP2Mode']
Fields after: ['ROP2Mode']
Bullshit after...
Name: EMR_SETROP2
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'ROP2Mode']
Here is a field: Type
Line index: 9064
Here is a field: Size
Line index: 9066
Here is a field: StretchMode
Line index: 9067
Bullshit before...
Name: EMR_SETSTRETCHBLTMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'StretchMode']
Fields before: ['Type', 'Size', 'StretchMode']
Fields after: ['StretchMode']
Bullshit after...
Name: EMR_SETSTRETCHBLTMODE
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'StretchMode']
Here is a field: Type
Line index: 9095
Here is a field: Size
Line index: 9097
Here is a field: TextAlignmentMode
Line index: 9098
Bullshit before...
Name: EMR_SETTEXTALIGN
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'TextAlignmentMode']
Fields before: ['Type', 'Size', 'TextAlignmentMode']
Fields after: ['TextAlignmentMode']
Bullshit after...
Name: EMR_SETTEXTALIGN
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'TextAlignmentMode']
Here is a field: Type
Line index: 9121
Here is a field: Size
Line index: 9123
Here is a field: Color
Line index: 9124
Bullshit before...
Name: EMR_SETTEXTCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Fields before: ['Type', 'Size', 'Color']
Fields after: ['Color']
Bullshit after...
Name: EMR_SETTEXTCOLOR
Here is the struct format: ['4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'Color']
Here is a field: Type
Line index: 9146
Here is a field: Size
Line index: 9148
Here is a field: nBreakExtra
Line index: 9149
Here is a field: nBreakCount
Line index: 9151
Bullshit before...
Name: EMR_SETTEXTJUSTIFICATION
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'nBreakExtra', 'nBreakCount']
Fields before: ['Type', 'Size', 'nBreakExtra', 'nBreakCount']
Fields after: ['nBreakExtra', 'nBreakCount']
Bullshit after...
Name: EMR_SETTEXTJUSTIFICATION
Here is the struct format: ['4b', '4b', '4b', '4b']
Here is the fields: ['Type', 'Size', 'nBreakExtra', 'nBreakCount']
Here is a field: Type
Line index: 9168
Here is a field: Size
Line index: 9170
Here is a field: Extent
Line index: 9171
Bullshit before...
Name: EMR_SETVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Fields before: ['Type', 'Size', 'Extent']
Fields after: ['Extent']
Bullshit after...
Name: EMR_SETVIEWPORTEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Here is a field: Type
Line index: 9192
Here is a field: Size
Line index: 9194
Here is a field: Origin
Line index: 9195
Bullshit before...
Name: EMR_SETVIEWPORTORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Fields before: ['Type', 'Size', 'Origin']
Fields after: ['Origin']
Bullshit after...
Name: EMR_SETVIEWPORTORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Here is a field: Type
Line index: 9211
Here is a field: Size
Line index: 9213
Here is a field: Extent
Line index: 9214
Bullshit before...
Name: EMR_SETWINDOWEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Fields before: ['Type', 'Size', 'Extent']
Fields after: ['Extent']
Bullshit after...
Name: EMR_SETWINDOWEXTEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Extent']
Here is a field: Type
Line index: 9235
Here is a field: Size
Line index: 9237
Here is a field: Origin
Line index: 9238
Bullshit before...
Name: EMR_SETWINDOWORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Fields before: ['Type', 'Size', 'Origin']
Fields after: ['Origin']
Bullshit after...
Name: EMR_SETWINDOWORGEX
Here is the struct format: ['4b', '4b', '8b']
Here is the fields: ['Type', 'Size', 'Origin']
Here is a field: Type
Line index: 9298
Here is a field: Size
Line index: 9300
Here is a field: Xform
Line index: 9302
Here is a field: ModifyWorldTransformMode
Line index: 9305
Bullshit before...
Name: EMR_MODIFYWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b', '4b']
Here is the fields: ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode']
Fields before: ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode']
Fields after: ['Xform', 'ModifyWorldTransformMode']
Bullshit after...
Name: EMR_MODIFYWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b', '4b']
Here is the fields: ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode']
Here is a field: Type
Line index: 9330
Here is a field: Size
Line index: 9332
Here is a field: Xform
Line index: 9334
Bullshit before...
Name: EMR_SETWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'Xform']
Fields before: ['Type', 'Size', 'Xform']
Fields after: ['Xform']
Bullshit after...
Name: EMR_SETWORLDTRANSFORM
Here is the struct format: ['4b', '4b', '24b']
Here is the fields: ['Type', 'Size', 'Xform']
class EMR_ALPHABLEND:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_ALPHABLEND"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BLENDFUNCTION', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ALPHABLEND {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_BITBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_BITBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_BITBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_MASKBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '2b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_MASKBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'ROP4', 'Reserved', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_MASKBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PLGBLT:
    format = ['4b', '4b', '16b', '24b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_PLGBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'aptlDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'xMask', 'yMask', 'UsageMask', 'offBmiMask', 'cbBmiMask', 'offBitsMask', 'cbBitsMask'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PLGBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETDIBITSTODEVICE:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETDIBITSTODEVICE"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'iStartScan', 'cScans'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETDIBITSTODEVICE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STRETCHBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_STRETCHBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'BitBltRasterOperation', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STRETCHBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STRETCHDIBITS:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_STRETCHDIBITS"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'xSrc', 'ySrc', 'cxSrc', 'cySrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'UsageSrc', 'BitBltRasterOperation', 'cxDest', 'cyDest'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STRETCHDIBITS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_TRANSPARENTBLT:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '24b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_TRANSPARENTBLT"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'xDest', 'yDest', 'cxDest', 'cyDest', 'TransparentColor', 'xSrc', 'ySrc', 'XformSrc', 'BkColorSrc', 'UsageSrc', 'offBmiSrc', 'cbBmiSrc', 'offBitsSrc', 'cbBitsSrc', 'cxSrc', 'cySrc'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_TRANSPARENTBLT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXCLUDECLIPRECT:
    format = ['4b', '4b', '16b']
    name = "EMR_EXCLUDECLIPRECT"
    has_variable = False
    fields = ['Type', 'Size', 'Clip'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXCLUDECLIPRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTSELECTCLIPRGN:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_EXTSELECTCLIPRGN"
    has_variable = True
    fields = ['Type', 'Size', 'RgnDataSize', 'RegionMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTSELECTCLIPRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_INTERSECTCLIPRECT:
    format = ['4b', '4b', '16b']
    name = "EMR_INTERSECTCLIPRECT"
    has_variable = False
    fields = ['Type', 'Size', 'Clip'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_INTERSECTCLIPRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_OFFSETCLIPRGN:
    format = ['4b', '4b', '8b']
    name = "EMR_OFFSETCLIPRGN"
    has_variable = False
    fields = ['Type', 'Size', 'Offset'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_OFFSETCLIPRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SELECTCLIPPATH:
    format = ['4b', '4b', '4b']
    name = "EMR_SELECTCLIPPATH"
    has_variable = False
    fields = ['Type', 'Size', 'RegionMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SELECTCLIPPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COMMENT:
    format = ['4b', '4b']
    name = "EMR_COMMENT"
    has_variable = False
    fields = ['Type', 'Size'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COMMENT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COMMENT_EMFPLUS:
    format = ['4b', '4b', '4b']
    name = "EMR_COMMENT_EMFPLUS"
    has_variable = True
    fields = ['Type', 'Size', 'CommentIdentifier'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COMMENT_EMFPLUS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COMMENT_EMFSPOOL:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_COMMENT_EMFSPOOL"
    has_variable = True
    fields = ['Type', 'Size', 'CommentIdentifier', 'EMFSpoolRecordIdentifier'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COMMENT_EMFSPOOL {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EOF:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_EOF"
    has_variable = True
    fields = ['Type', 'Size', 'nPalEntries', 'offPalEntries', 'SizeLast'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EOF {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ANGLEARC:
    format = ['4b', '4b', '8b', '4b', '4b', '4b']
    name = "EMR_ANGLEARC"
    has_variable = False
    fields = ['Type', 'Size', 'Center', 'Radius', 'StartAngle', 'SweepAngle'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ANGLEARC {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ARC:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_ARC"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ARC {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ARCTO:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_ARCTO"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ARCTO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CHORD:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_CHORD"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CHORD {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ELLIPSE:
    format = ['4b', '4b', '16b']
    name = "EMR_ELLIPSE"
    has_variable = False
    fields = ['Type', 'Size', 'Box'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ELLIPSE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTFLOODFILL:
    format = ['4b', '4b', '8b', '4b', '4b']
    name = "EMR_EXTFLOODFILL"
    has_variable = False
    fields = ['Type', 'Size', 'Start', 'Color', 'FloodFillMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTFLOODFILL {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTTEXTOUTA:
    format = ['4b', '4b', '16b', '4b', '4b', '4b']
    name = "EMR_EXTTEXTOUTA"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTTEXTOUTA {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTTEXTOUTW:
    format = ['4b', '4b', '16b', '4b', '4b', '4b']
    name = "EMR_EXTTEXTOUTW"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTTEXTOUTW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FILLPATH:
    format = ['4b', '4b', '16b']
    name = "EMR_FILLPATH"
    has_variable = False
    fields = ['Type', 'Size', 'Bounds'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FILLPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FILLRGN:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_FILLRGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FILLRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FRAMERGN:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
    name = "EMR_FRAMERGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize', 'ihBrush', 'Width', 'Height'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FRAMERGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_GRADIENTFILL:
    format = ['4b', '4b', '16b', '4b', '4b', '4b']
    name = "EMR_GRADIENTFILL"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'nVer', 'nTri', 'ulMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_GRADIENTFILL {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_LINETO:
    format = ['4b', '4b', '8b']
    name = "EMR_LINETO"
    has_variable = False
    fields = ['Type', 'Size', 'Point'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_LINETO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PAINTRGN:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_PAINTRGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PAINTRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PIE:
    format = ['4b', '4b', '16b', '8b', '8b']
    name = "EMR_PIE"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Start', 'End'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PIE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIER:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIER"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIER {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIER16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIER16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIER16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIERTO:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIERTO"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIERTO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYBEZIERTO16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYBEZIERTO16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYBEZIERTO16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYDRAW:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYDRAW"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYDRAW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYDRAW16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYDRAW16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYDRAW16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYGON:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYGON"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYGON {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYGON16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYGON16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYGON16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINE:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINE"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINE16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINE16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINE16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINETO:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINETO"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINETO {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYLINETO16:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_POLYLINETO16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYLINETO16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYGON:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYGON"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYGON {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYGON16:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYGON16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolygons', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYGON16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYLINE:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYLINE"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYLINE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYPOLYLINE16:
    format = ['4b', '4b', '16b', '4b', '4b']
    name = "EMR_POLYPOLYLINE16"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'NumberOfPolylines', 'Count'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYPOLYLINE16 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYTEXTOUTA:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
    name = "EMR_POLYTEXTOUTA"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYTEXTOUTA {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_POLYTEXTOUTW:
    format = ['4b', '4b', '16b', '4b', '4b', '4b', '4b']
    name = "EMR_POLYTEXTOUTW"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'iGraphicsMode', 'exScale', 'eyScale', 'cStrings'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_POLYTEXTOUTW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_RECTANGLE:
    format = ['4b', '4b', '16b']
    name = "EMR_RECTANGLE"
    has_variable = False
    fields = ['Type', 'Size', 'Box'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_RECTANGLE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_ROUNDRECT:
    format = ['4b', '4b', '16b', '8b']
    name = "EMR_ROUNDRECT"
    has_variable = False
    fields = ['Type', 'Size', 'Box', 'Corner'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_ROUNDRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETPIXELV:
    format = ['4b', '4b', '8b', '4b']
    name = "EMR_SETPIXELV"
    has_variable = False
    fields = ['Type', 'Size', 'Pixel', 'Color'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETPIXELV {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SMALLTEXTOUT:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SMALLTEXTOUT"
    has_variable = True
    fields = ['Type', 'Size', 'x', 'y', 'cChars', 'fuOptions', 'iGraphicsMode', 'exScale', 'eyScale'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SMALLTEXTOUT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STROKEANDFILLPATH:
    format = ['4b', '4b', '16b']
    name = "EMR_STROKEANDFILLPATH"
    has_variable = False
    fields = ['Type', 'Size', 'Bounds'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STROKEANDFILLPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_STROKEPATH:
    format = ['4b', '4b', '16b']
    name = "EMR_STROKEPATH"
    has_variable = False
    fields = ['Type', 'Size', 'Bounds'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_STROKEPATH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_DRAWESCAPE:
    format = ['4b', '4b', '4b']
    name = "EMR_DRAWESCAPE"
    has_variable = True
    fields = ['Type', 'Size', 'cjIn'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_DRAWESCAPE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTESCAPE:
    format = ['4b', '4b', '4b']
    name = "EMR_EXTESCAPE"
    has_variable = True
    fields = ['Type', 'Size', 'cjIn'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTESCAPE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_NAMEDESCAPE:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_NAMEDESCAPE"
    has_variable = True
    fields = ['Type', 'Size', 'cjDriver', 'cjIn'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_NAMEDESCAPE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEBRUSHINDIRECT:
    format = ['4b', '4b', '4b', '12b']
    name = "EMR_CREATEBRUSHINDIRECT"
    has_variable = False
    fields = ['Type', 'Size', 'ihBrush', 'LogBrush'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEBRUSHINDIRECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATECOLORSPACE:
    format = ['4b', '4b', '4b']
    name = "EMR_CREATECOLORSPACE"
    has_variable = True
    fields = ['Type', 'Size', 'ihCS'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATECOLORSPACE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATECOLORSPACEW:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_CREATECOLORSPACEW"
    has_variable = True
    fields = ['Type', 'Size', 'ihCS', 'dwFlags', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATECOLORSPACEW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEDIBPATTERNBRUSHPT:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_CREATEDIBPATTERNBRUSHPT"
    has_variable = True
    fields = ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEDIBPATTERNBRUSHPT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEMONOBRUSH:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_CREATEMONOBRUSH"
    has_variable = True
    fields = ['Type', 'Size', 'ihBrush', 'Usage', 'offBmi', 'cbBmi', 'offBits', 'cbBits'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEMONOBRUSH {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEPALETTE:
    format = ['4b', '4b', '4b']
    name = "EMR_CREATEPALETTE"
    has_variable = True
    fields = ['Type', 'Size', 'ihPal'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_CREATEPEN:
    format = ['4b', '4b', '4b', '16b']
    name = "EMR_CREATEPEN"
    has_variable = False
    fields = ['Type', 'Size', 'ihPen', 'LogPen'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_CREATEPEN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTCREATEFONTINDIRECTW:
    format = ['4b', '4b', '4b']
    name = "EMR_EXTCREATEFONTINDIRECTW"
    has_variable = True
    fields = ['Type', 'Size', 'ihFonts'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTCREATEFONTINDIRECTW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_EXTCREATEPEN:
    format = ['4b', '4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_EXTCREATEPEN"
    has_variable = True
    fields = ['Type', 'Size', 'ihPen', 'offBmi', 'cbBmi', 'offBits', 'cbBits'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_EXTCREATEPEN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COLORCORRECTPALETTE:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_COLORCORRECTPALETTE"
    has_variable = False
    fields = ['Type', 'Size', 'ihPalette', 'nFirstEntry', 'nPalEntries', 'nReserved'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COLORCORRECTPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_DELETECOLORSPACE:
    format = ['4b', '4b', '4b']
    name = "EMR_DELETECOLORSPACE"
    has_variable = False
    fields = ['Type', 'Size', 'ihCS'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_DELETECOLORSPACE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_DELETEOBJECT:
    format = ['4b', '4b', '4b']
    name = "EMR_DELETEOBJECT"
    has_variable = False
    fields = ['Type', 'Size', 'ihObject'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_DELETEOBJECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_RESIZEPALETTE:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_RESIZEPALETTE"
    has_variable = False
    fields = ['Type', 'Size', 'ihPal', 'NumberOfEntries'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_RESIZEPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SELECTOBJECT:
    format = ['4b', '4b', '4b']
    name = "EMR_SELECTOBJECT"
    has_variable = False
    fields = ['Type', 'Size', 'ihObject'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SELECTOBJECT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SELECTPALETTE:
    format = ['4b', '4b', '4b']
    name = "EMR_SELECTPALETTE"
    has_variable = False
    fields = ['Type', 'Size', 'ihPal'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SELECTPALETTE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETCOLORSPACE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETCOLORSPACE"
    has_variable = False
    fields = ['Type', 'Size', 'ihCS'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETCOLORSPACE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETPALETTEENTRIES:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETPALETTEENTRIES"
    has_variable = True
    fields = ['Type', 'Size', 'ihPal', 'Start', 'NumberofEntries'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETPALETTEENTRIES {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_GLSBOUNDEDRECORD:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_GLSBOUNDEDRECORD"
    has_variable = False
    fields = ['Type', 'Size', 'Bounds', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_GLSBOUNDEDRECORD {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_GLSRECORD:
    format = ['4b', '4b', '4b']
    name = "EMR_GLSRECORD"
    has_variable = False
    fields = ['Type', 'Size', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_GLSRECORD {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_COLORMATCHTOTARGETW:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_COLORMATCHTOTARGETW"
    has_variable = True
    fields = ['Type', 'Size', 'dwAction', 'dwFlags', 'cbName', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_COLORMATCHTOTARGETW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_FORCEUFIMAPPING:
    format = ['4b', '4b', '8b']
    name = "EMR_FORCEUFIMAPPING"
    has_variable = False
    fields = ['Type', 'Size', 'ufi'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_FORCEUFIMAPPING {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_INVERTRGN:
    format = ['4b', '4b', '16b', '4b']
    name = "EMR_INVERTRGN"
    has_variable = True
    fields = ['Type', 'Size', 'Bounds', 'RgnDataSize'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_INVERTRGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_MOVETOEX:
    format = ['4b', '4b', '8b']
    name = "EMR_MOVETOEX"
    has_variable = False
    fields = ['Type', 'Size', 'Offset'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_MOVETOEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_PIXELFORMAT:
    format = ['4b', '4b', '40b']
    name = "EMR_PIXELFORMAT"
    has_variable = False
    fields = ['Type', 'Size', 'pfd'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_PIXELFORMAT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_RESTOREDC:
    format = ['4b', '4b', '4b']
    name = "EMR_RESTOREDC"
    has_variable = False
    fields = ['Type', 'Size', 'SavedDC'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_RESTOREDC {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SCALEVIEWPORTEXTEX:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SCALEVIEWPORTEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SCALEVIEWPORTEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SCALEWINDOWEXTEX:
    format = ['4b', '4b', '4b', '4b', '4b', '4b']
    name = "EMR_SCALEWINDOWEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'xNum', 'xDenom', 'yNum', 'yDenom'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SCALEWINDOWEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETARCDIRECTION:
    format = ['4b', '4b', '4b']
    name = "EMR_SETARCDIRECTION"
    has_variable = False
    fields = ['Type', 'Size', 'ArcDirection'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETARCDIRECTION {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETBKCOLOR:
    format = ['4b', '4b', '4b']
    name = "EMR_SETBKCOLOR"
    has_variable = False
    fields = ['Type', 'Size', 'Color'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETBKCOLOR {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETBKMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETBKMODE"
    has_variable = False
    fields = ['Type', 'Size', 'BackgroundMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETBKMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETBRUSHORGEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETBRUSHORGEX"
    has_variable = False
    fields = ['Type', 'Size', 'Origin'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETBRUSHORGEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETCOLORADJUSTMENT:
    format = ['4b', '4b', '24b']
    name = "EMR_SETCOLORADJUSTMENT"
    has_variable = False
    fields = ['Type', 'Size', 'ColorAdjustment'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETCOLORADJUSTMENT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETICMMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETICMMODE"
    has_variable = False
    fields = ['Type', 'Size', 'ICMMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETICMMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETICMPROFILEA:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETICMPROFILEA"
    has_variable = True
    fields = ['Type', 'Size', 'dwFlags', 'cbName', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETICMPROFILEA {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETICMPROFILEW:
    format = ['4b', '4b', '4b', '4b', '4b']
    name = "EMR_SETICMPROFILEW"
    has_variable = True
    fields = ['Type', 'Size', 'dwFlags', 'cbName', 'cbData'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETICMPROFILEW {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETLAYOUT:
    format = ['4b', '4b', '4b']
    name = "EMR_SETLAYOUT"
    has_variable = False
    fields = ['Type', 'Size', 'LayoutMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETLAYOUT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETLINKEDUFIS:
    format = ['4b', '4b', '4b', '8b']
    name = "EMR_SETLINKEDUFIS"
    has_variable = True
    fields = ['Type', 'Size', 'uNumLinkedUFI', 'Reserved'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETLINKEDUFIS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETMAPMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETMAPMODE"
    has_variable = False
    fields = ['Type', 'Size', 'MapMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETMAPMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETMAPPERFLAGS:
    format = ['4b', '4b', '4b']
    name = "EMR_SETMAPPERFLAGS"
    has_variable = False
    fields = ['Type', 'Size', 'Flags'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETMAPPERFLAGS {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETMITERLIMIT:
    format = ['4b', '4b', '4b']
    name = "EMR_SETMITERLIMIT"
    has_variable = False
    fields = ['Type', 'Size', 'MiterLimit'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETMITERLIMIT {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETPOLYFILLMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETPOLYFILLMODE"
    has_variable = False
    fields = ['Type', 'Size', 'PolygonFillMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETPOLYFILLMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETROP2:
    format = ['4b', '4b', '4b']
    name = "EMR_SETROP2"
    has_variable = False
    fields = ['Type', 'Size', 'ROP2Mode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETROP2 {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETSTRETCHBLTMODE:
    format = ['4b', '4b', '4b']
    name = "EMR_SETSTRETCHBLTMODE"
    has_variable = False
    fields = ['Type', 'Size', 'StretchMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETSTRETCHBLTMODE {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETTEXTALIGN:
    format = ['4b', '4b', '4b']
    name = "EMR_SETTEXTALIGN"
    has_variable = False
    fields = ['Type', 'Size', 'TextAlignmentMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETTEXTALIGN {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETTEXTCOLOR:
    format = ['4b', '4b', '4b']
    name = "EMR_SETTEXTCOLOR"
    has_variable = False
    fields = ['Type', 'Size', 'Color'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETTEXTCOLOR {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETTEXTJUSTIFICATION:
    format = ['4b', '4b', '4b', '4b']
    name = "EMR_SETTEXTJUSTIFICATION"
    has_variable = False
    fields = ['Type', 'Size', 'nBreakExtra', 'nBreakCount'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETTEXTJUSTIFICATION {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETVIEWPORTEXTEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETVIEWPORTEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'Extent'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETVIEWPORTEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETVIEWPORTORGEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETVIEWPORTORGEX"
    has_variable = False
    fields = ['Type', 'Size', 'Origin'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETVIEWPORTORGEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETWINDOWEXTEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETWINDOWEXTEX"
    has_variable = False
    fields = ['Type', 'Size', 'Extent'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETWINDOWEXTEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETWINDOWORGEX:
    format = ['4b', '4b', '8b']
    name = "EMR_SETWINDOWORGEX"
    has_variable = False
    fields = ['Type', 'Size', 'Origin'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETWINDOWORGEX {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_MODIFYWORLDTRANSFORM:
    format = ['4b', '4b', '24b', '4b']
    name = "EMR_MODIFYWORLDTRANSFORM"
    has_variable = False
    fields = ['Type', 'Size', 'Xform', 'ModifyWorldTransformMode'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_MODIFYWORLDTRANSFORM {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes




class EMR_SETWORLDTRANSFORM:
    format = ['4b', '4b', '24b']
    name = "EMR_SETWORLDTRANSFORM"
    has_variable = False
    fields = ['Type', 'Size', 'Xform'] # These are the fields of this object.
    variable_data = None
    def __init__(self, data):
        unpacked = []
        for f in self.format:
            unpacked.append(struct.unpack(f, data[:struct.calcsize(f)]))
            data = data[struct.calcsize(f):]
        #print("unpacked: ")
        #print(unpacked)
        for field, value in zip(self.fields, unpacked):
            #print("value == "+str(value))
            if isinstance(value, tuple): # This is a multibyte value.
                # Should be integers all
                # Convert to unsigned bytes...
                value = [to_unsigned(x) for x in value]
                assert all([x >= 0 and x <= 255 for x in value]) # Should be integers representing single bytes.
                # Make a list and then just use bytes
                b = bytes(value)
                # Now make the integer...
                # int.from_bytes(byte_data, byteorder='little')
                integer = int.from_bytes(b, byteorder='little')
                setattr(self, field, (len(b), integer))
            else:
                value = to_unsigned(value)
                assert value >= 0 and value <= 255 
                setattr(self, field, (1, value)) # Size of one byte
        self.remaining_data = data[struct.calcsize("".join(self.format)):]
        #print("Here is the size thing: "+str(struct.calcsize("".join(self.format))))
        # return self.remaining_data # Return the remaining data after reading the header.
        # Sanity checking. If the record doesn't have variable fields, then all of the data should be consumed. Otherwise this is an error condition.
        print("Here is self.name: "+str(self.name))
        print("Here is self.has_variable: "+str(self.has_variable))
        print("Here is self.remaining_data: "+str(self.remaining_data))
        if not self.has_variable and self.remaining_data: # There is left over data even though record should not be variable.
            assert False
        if self.has_variable:
            # Set the variable data.
            self.variable_data = self.remaining_data # The variable data should be the data at the end. This actually may be b"" for optional fields...


    @classmethod
    def from_file(cls, filename):
        with open(filename, 'rb') as f:
            data = f.read()
            return cls(data)

    def __repr__(self):
        parsed_fields = {field: getattr(self, field) for field in self.fields}
        return f"<EMR_SETWORLDTRANSFORM {parsed_fields}, Remaining: {len(self.remaining_data)} bytes>"

    def serialize(self):
        out = b"" # Initialize empty bytes output
        for i, format_string in enumerate(self.format):
            # The corresponding field is fields[i]
            field_name = self.fields[i]
            field_val = getattr(self, field_name) # Get the actual value of the field from this object.
            field_length = field_val[0]
            field_integer = field_val[1]
            # Now try to unpack the integer into the format.
            # field_bytes = struct.pack(format_string, field_val)
            field_bytes = field_integer.to_bytes(field_length, byteorder='little') # num.to_bytes(4, byteorder='little')
            out += field_bytes # Add the actual value to the output
        if self.has_variable:
            # Add variable data to the end.
            out += self.variable_data
        # Sanity checking. The "Size" field should actually match the size upon serialization. If not, then the mutator did not take care of the size correctly and there is a bug in the mutator.
        assert self.Size == len(out)
        return out # Return the output bytes





